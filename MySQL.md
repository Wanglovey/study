# MySQL基础

## MySQL概述

### 数据库相关概念

1、数据库（DataBase，DB）

存储数据的仓库，数据是有组织的进行存储

2、数据库管理系统（DataBase Management System，DBMS）

操纵和管理数据库的大型软件

3、SQL（Structured Query Language）

操作关系型数据库的编程语言，定义了一套操作关系型数据库的统一标准

4、主流的关系型数据库管理系统：

Oracle、MySQL、SQL Server、PostgreSQL、IBM Db2、Microsoft Access、SQLite

5、关系型数据库（RDBMS）：

概念：建立在关系模型基础上，由多张相互连接的二维表组成的数据库

特点：

1.使用表存储数据，格式统一，便于维护

2.使用SQL语言操作，标准统一，使用方便

### MySQL数据库

1、版本

MySQL官方提供了两种不同的版本：

社区版（MySQL Community Server）

免费，MySQL不提供任何技术支持

商业版（MySQL Enterprise Edition）

收费，可以试用30天，官方提供技术支持

2、启动与停止（需要管理员模式）

启动：在命令行中输入net start mysql80

停止：在命令行中输入net stop mysql80

3、客户端连接

方式一：

使用MySQL提供的客户端命令行工具

方式二：

输入mysql [-h IP地址] [-p 3306] -u root -p

4、数据模型

用户在客户端连接DBMS，之后可以利用DBMS创建数据库，然后在数据库中创建表

## SQL

### SQL通用语法

1、SQL语句可以单行或多行书写，以分号结尾

2、SQL语句可以使用空格/缩进来增强语句的可读性

3、MySQL数据库的SQL语句不区分大小写，关键词建议使用大写

4、注释：

单行注释：--注释内容	或	#注释内容（MySQL特有）

多行注释：/* 注释内容 */

### SQL分类

DDL	Data Definition Language	 数据定义语言，用来定义数据库对象(数据库，表，字段)

DML	Data Manipulation Language	 数据操作语言，用来对数据库表中数据进行增删改

DQL	Data Query Language	 数据查询语言，用来查询数据库中表的记录

DCL	Data Control Language	 数据控制语言，用来创建数据库用户、控制数据库的访问

### MySQL图形化界面

sqlyog、Navicat、DataGrip

### SQL数据类型

1、数值类型

| 类型         | 大小    | 有符号(SIGNED)范围                                    | 无符号(UNSIGNED)范围                                      | 描述               |
| ------------ | ------- | ----------------------------------------------------- | --------------------------------------------------------- | ------------------ |
| tinyint      | 1 byte  | (-128，127)                                           | (0，255)                                                  | 小整数值           |
| smallint     | 2 bytes | (-32768，32767)                                       | (0，65535)                                                | 大整数值           |
| mediumint    | 3 bytes | (-8388608，8388607)                                   | (0，16777215)                                             | 大整数值           |
| int或integer | 4 bytes | (-2147483648，2147483647)                             | (0，4294967295)                                           | 大整数值           |
| bigint       | 8 bytes | (-2^63，2^63-1)                                       | (0，2^64-1)                                               | 极大整数值         |
| float        | 4 bytes | (-3.402823466 E+38，3.402823466351 E+38)              | 0 和 (1.175494351 E-38，3.402823466 E+38)                 | 单精度浮点数值     |
| double       | 8 bytes | (-1.7976931348623157 E+308，1.7976931348623157 E+308) | 0 和 (2.2250738585072014 E-308，1.7976931348623157 E+308) | 双精度浮点数值     |
| decimal      |         | 依赖于M(精度)和D(标度)的值                            | 依赖于M(精度)和D(标度)的值                                | 小数值(精确定点数) |

2、字符串类型

| 类型       | 大小                  | 描述                         |
| ---------- | --------------------- | ---------------------------- |
| char       | 0-255 bytes           | 定长字符串                   |
| varchar    | 0-65535 bytes         | 变长字符串                   |
| tinyblob   | 0-255 bytes           | 不超过255个字符的二进制数据  |
| tinytext   | 0-255 bytes           | 短文本字符串                 |
| blob       | 0-65 535 bytes        | 二进制形式的长文本数据       |
| text       | 0-65 535 bytes        | 长文本数据                   |
| mediumblob | 0-16 777 215 bytes    | 二进制形式的中等长度文本数据 |
| mediumtext | 0-16 777 215 bytes    | 中等长度文本数据             |
| longblob   | 0-4 294 967 295 bytes | 二进制形式的极大文本数据     |
| longtext   | 0-4 294 967 295 bytes | 极大文本数据                 |

注意：char性能要优于varchar，blob类型用得比较少

3、日期类型

| 类型      | 大小 | 范围                                       | 格式                | 描述                     |
| --------- | ---- | ------------------------------------------ | ------------------- | ------------------------ |
| date      | 3    | 1000-01-01 至 9999-12-31                   | YYYY-MM-DD          | 日期值                   |
| time      | 3    | -838:59:59 至 838:59:59                    | HH:MM:SS            | 时间值或持续时间         |
| year      | 1    | 1901 至 2155                               | YYYY                | 年份值                   |
| datetime  | 8    | 1000-01-01 00:00:00 至 9999-12-31 23:59:59 | YYYY-MM-DD HH:MM:SS | 混合日期和时间值         |
| timestamp | 4    | 1970-01-01 00:00:01 至 2038-01-19 03:14:07 | YYYY-MM-DD HH:MM:SS | 混合日期和时间值，时间戳 |

4、枚举类型

mysql提供了一种特殊的类型enum，用来限制离散型数据的插入值

用法：

```mysql
create table user(
	sex enum('男','女','保密')
);
```



### DDL

1、DDL-数据库操作

1)查询所有数据库

```
show databases;
```

2)查询当前所使用的数据库

```
select database();
```

3）创建数据库

```
create database [if not exists] 数据库名 [default charset 字符集] [collate 排序规则];
```

4）删除数据库

```
drop database [ if exists ] 数据库名;
```

5）使用数据库

```
use 数据库名;
```

2、DDL-表操作

1）查询当前数据库所有表

```
show tables;
```

2）查询表结构

```
desc 表名;
```

3）查询指定表的建表语句

```
show create table 表名;
```

4）创建表

```
create table 表名(

字段1 字段1类型 [ comment 字段1注释 ],

字段2 字段2类型 [ comment 字段2注释 ],

字段3 字段3类型 [ comment 字段3注释 ],

......

字段n 字段n类型 [ comment 字段n注释 ]

) [ comment 表注释 ];
```

> 注意：[ ... ]为可选参数，最后一个字段后面没有逗号

5）在表中添加字段

```
alter table 表名 add 字段名 类型(长度) [comment 注释] [约束];
```

6）修改字段的数据类型

```
alter table 表名 modify 字段名 新数据类型(长度);
```

7）修改字段名和字段类型

```
alter table 表名 change 旧字段名 新字段名 类型(长度) [comment 注释] [约束];
```

8）删除字段

```
alter table 表名 drop 字段名;
```

9）修改表名

```
alter table 表名 rename to 新表名;
```

10）删除表

```
drop table [if exists] 表名;
```

11）删除指定表，并重新创建该表

```
truncate table 表名;
```

### 1.2.6. DML

1、DML-添加数据（insert）

1）给指定字段添加数据

```
insert into 表名(字段名1,字段名2,...) values(值1,值2,...)；
```

2）给全部字段添加数据

```
insert into 表名 values(值1,值2,...)；
```

3）批量添加数据

```
insert into 表名(字段名1,字段名2,...) values(值1,值2,...),(值1,值2,...)；

insert into 表名 values(值1,值2,...),(值1,值2,...),(值1,值2,...)；
```

> 注意：
>
> 插入数据时，指定的字段顺序需要与值的顺序一一对应
>
> 字符串和日期型数据应该包含在引号中
>
> 插入的数据大小，应该在字段的规定范围内

 

2、DML-修改数据（update）

```
update 表名 set 字段名1=值1,字段名2=值2,...[where 条件]
```

> 注意：修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据

 

3、DML删除数据

```
delete from 表名 [where 条件]
```

> 注意：
>
> delete语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数据
>
> delete语句不能删除某一个字段的值（可以使用update）

 

### 1.2.7. DQL

1、语法：

```
select

字段1[as 别名1],字段2[as 别名2],...（*可代替所有字段，as也可省略）

from

表名1,表名2,...

where

条件1 and/or 条件2...

group by

分组字段列表

having

分组后条件列表

order by

字段1 排序方式,字段2 排序方式;

limit

起始索引,每页查询的页数
```

2、基本查询：

```
select 字段...from 表名;

select * from 表名;
```

3、设置别名：

```
select 字段1[as 别名],字段2[as 别名2] ... from 表名;
```

> 注意：as可以省略，即可以直接写成select 字段1 别名 的形式

4、去除重复记录

```
select distinct 字段列表 from 表名;
```

5、条件查询

```
select 字段列表 from 表名 where 条件列表
```

> where中的条件需要采用and或者or进行分隔，不能使用,进行分隔
>

比较运算符

```
\>		大于

\>=		大于等于

<		小于

<=		小于等于

=		等于

<>或!=	不等于

between...and...	在某个范围之内（含最大、最小值）

in(...)		在in之后的列表中的值，多选

like 占位符		模糊匹配（_匹配单个字符，%匹配任意个字符）

is NULL		是NULL
```

逻辑运算符

```
and 或 &&		并且

or 或 ||			或者

not 或 !		非，不是
```



6、聚合函数（count、max、min、avg、sum）

将一列数据作为一个整体，进行纵向计算

常见聚合函数：

```
count	统计数量

max	最大值

min	最小值

avg		平均值

sum	求和
```

例如：

```
select count(*) from 表;		//统计表的行数
```

> 注意：null值不参与所有聚合函数运算



7、分组查询

```
select 字段列表 from 表名 [where 条件] group by 分组字段名 [having 分组后的过滤条件]
```

> 排序方式：
>
> ASC：升序（默认值）
>
> DESC：降序

> where和having的区别
>
> 执行时机不同：where是分组之前进行过滤，不满足where，不参与分组，而having	是分组之后对结果进行过滤
>
> 判断条件不同：where不能对聚合函数进行判断，而having可以

> 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无意义



8、分页查询

```
select 字段列表 from 表名 limit 起始索引,查询记录数;
```

> 注意：
>
> 起始索引从0开始，起始索引 = (查询页码-1) *每页显示记录数.
>
> 分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是limit
>
> 如果查询的是第一页数据，其实索引可以省略，直接简写为limit 10

 

9、DQL语句的执行顺序

```
from>where>group by>having>select>order by>limit
```



### DCL

DCL（Data Control Language，数据控制语言），用来管理数据库用户并控制数据库的访问权限 

#### DCL管理用户

1）查询用户

用户信息是被存储在系统数据库mysql中，可以通过查询user表来查看用户信息

```
use mysql;
select * from user;
```

2）创建用户 

```mysql
create user '用户名'@'主机名' identified by '密码'
```

> 用户名为一个字符串，即新创建用户的用户名，注意该用户名不能与之前的用户重名

> 主机名为表示该用户能够访问数据库的主机，可选项为 `'localhost'` 或者 `'%'` ， `'%'` 表示可以在任意主机上访问数据库

> identified by 后需要加一个字符串，表示新创建用户的密码，注意新创建用户还未被分配权限，因此新创建的用户仅能访问mysql，但没有访问数据库的权限

3）修改用户密码

```mysql
alter user '用户名'@'主机名' identified with mysql_native_password by '新密码'
```

4）删除用户

```
drop user '用户名'@'主机名'
```

> 注意：DCL操作SQL开发人员操作得比较少，主要是DBA（Database Administrator，数据库管理员）使用

#### DCL权限控制

1、MySQL中的常用权限

|        权限        |        说明        |
| :----------------: | :----------------: |
| all,all privileges |      所有权限      |
|       select       |      查询数据      |
|       insert       |      插入数据      |
|       update       |      修改数据      |
|       delete       |      删除数据      |
|       alter        |       修改表       |
|        drop        | 删除数据库/表/视图 |
|       create       |   创建数据库/表    |



2、查询权限

```mysql
show grants for '用户名'@'主机名'
```

3、授予权限

```mysql
grant 权限列表 on 数据库名.表名 to '用户名'@'主机名' [with grant option]
```

> with grant option表示该用户可以将该权限授予另一个用户，如果不写则表示不可授予

4、撤销权限

```
revoke 权限列表 on 数据库名.表名 from '用户名'@'主机名'
```

> 注意：
>
> - 多个权限之间使用逗号进行分隔
> - 授权时，数据库名和表名都可以使用*进行通配，代表所有

## 函数

函数是指一段可以直接被另一端程序调用的程序或代码

### 字符串函数

|           函数           |                             功能                             |
| :----------------------: | :----------------------------------------------------------: |
|   concat(s1,s2,...sn)    |                   字符串拼接，将s1,s2...sn                   |
|        lower(str)        |                   将字符串str全部转为小写                    |
|        upple(str)        |                   将字符串str全部转为大写                    |
|     lpad(str,n,pad)      |  左填充，用字符串pad对str的左边进行填充，达到n个字符串长度   |
|     rpad(str,n,pad)      |  右填充，用字符串pad对str的右边进行填充，达到n个字符串长度   |
|        trim(str)         |                  去掉字符串头部和尾部的空格                  |
| substring(str,start,len) | 返回从字符串str从start位置起的len个长度的字符串，注意其索引值是从1开始的 |

### 数值函数

|    函数    |                功能                |
| :--------: | :--------------------------------: |
|  ceil(x)   |              向上取整              |
|  floor(x)  |              向下取整              |
|  mod(x,y)  |          返回x mod y的值           |
|   rand()   |         返回0~1内的随机数          |
| round(x,y) | 求参数x的四舍五入的值，保留y位小数 |



### 日期函数

|               函数                |                       功能                        |
| :-------------------------------: | :-----------------------------------------------: |
|             curdate()             |                   返回当前日期                    |
|             curtime()             |                   返回当前时间                    |
|               now()               |                返回当前日期和时间                 |
|            year(date)             |                获取指定date的年份                 |
|            month(date)            |                获取指定date的月份                 |
|             day(date)             |                获取指定date的日期                 |
| date_add(date,interval expr type) | 返回一个日期/时间值加上一个时间间隔expr后的时间值 |
|       datediff(date1,date2)       |    返回起始时间date1和结束时间date2之间的天数     |



### 流程控制函数

|                           函数                           |                          功能                           |
| :------------------------------------------------------: | :-----------------------------------------------------: |
|                      if(value,t,f)                       |           如果value为true，则返回t，否则返回f           |
|                  ifNULL(value1,value2)                   |      如果value1不为空，返回value1，否则返回value2       |
|    case when [val1] then [res1]...else [default] end     |    如果val1为true，返回res1,...否则返回default默认值    |
| case [expr] when [val1] then [res1]...else [default] end | 如果expr的值等于val1，返回res1,...否则返回default默认值 |

> 注意第四条的标准写法为
>
> ```mysql
> case [expr]
> 	when [val1] then [res1]
> 	when [val2] then [res2]
> 	......
> 	else [default]
> end
> ```



## 约束

### 概述

约束是作用于表中字段上的规则，用于限制存储在表中的数据

约束的目的：保证数据库中数据的正确性、有效性和完整性

约束的分类：

|   约束   |                           描述                           |   关键字    |
| :------: | :------------------------------------------------------: | :---------: |
| 非空约束 |                 限制字段的数据不能为null                 |  not null   |
| 唯一约束 |         保证该字段的所有数据都是唯一的、不重复的         |   unique    |
| 主键约束 |         主键是一行数据的唯一标识，要求非空且唯一         | primary key |
| 默认约束 |      保存数据时，如果未指定该字段的值，则采用默认值      |   default   |
| 检查约束 |                 保证字段值满足某一个条件                 |    check    |
| 外键约束 | 用来让两张表的数据之间建立连接，保证数据的一致性和完整性 | foreign key |

实例1：

| 字段名 |  字段类型   |         约束条件          |          约束条件           |
| :----: | :---------: | :-----------------------: | :-------------------------: |
|   id   |     int     |    主键，并且自动增长     | primary key，auto_increment |
|  name  | varchar(10) |     不为空，并且唯一      |      not null，unique       |
|  age   |     int     |  大于0，并且小于等于120   |            check            |
| status |   char(1)   | 如果没有指定该值，默认为1 |           default           |
| gender |   char(1)   |            无             |                             |

> 注意：auto_increment可以用于自动生成升序序列，只适用于整数类型数据列
>
> auto_increment仅在mysql中才有
>
> 当插入记录时，如果为AUTO_INCREMENT数据列明确指定了一个数值，则会出现两种情况
>
> 情况一，如果插入的值与已有的编号重复，则会出现出错信息，因为AUTO_INCREMENT数据列的值必须是唯一的
>
> 情况二，如果插入的值大于已编号的值，则会把该插入到数据列中，并使在下一个编号将从这个新值开始递增。也就是说，可以跳过一些编号
>
> 如果自增序列的最大值被删除了，则在插入新记录时，该值被重用。
>
> 如果用UPDATE命令更新自增列，如果列值与已有的值重复，则会出错。如果大于已有值，则下一个编号从该值开始递增。

```mysql
create table user(
    id int primary key auto_increment comment '主键',
    name varchar(10) not null unique comment '姓名',
    age int check(age>0 && age<=120) comment '年龄',
    status char(1) default '1' comment '状态',
    gender char(1) comment '性别'
) comment '用户表'
```

### 外键约束详解

1、子表和父表

设置了外键约束的表被称为子表，连接到的表被称为父表

2、外键的作用

如果设置了外键，则当删除或者更新时，需要按照外键的删除/更新行为判定时候能够成功删除/更新

3、建立外键关联的语法：

```mysql
// 法一（建立表时指定）
create table 表名(
	字段名 数据类型,
	...
	[constraint] [外键名称] foreign key(外键字段) references 主表名(主表字段名) [on update cascade on delete cascade]
)
// 法二（建立表后指定）
alter table 表名 add constraint 外键名称 foreign key(外键字段) references 主表名(主表字段名) [on update cascade on delete cascade]
```

4、删除外键关联的语法：

```mysql
alter table 表名 drop foreign key 外键名称
```

5、删除/更新行为

|    行为     |                             说明                             |
| :---------: | :----------------------------------------------------------: |
|  no action  | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与restrict一致） |
|  restrict   | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与no action一致） |
|   cascade   | 级联，当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除/更新外键在子表中的记录 |
|  set null   | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（需要满足外键可以取null的要求) |
| set default | 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为默认值（innodb引擎不支持) |

语法：

```mysql
alter table 表名 add constraint 外键名称 foreign key(外键字段) references 主表名(主表字段名) on update cascade on delete cascade
```



## 多表查询

### 多表关系

- 一对多（多对一）

例如：一个部门对应多个员工，一个员工对应一个部门

实现方式：在多的一方建立主键，指向一的一方的主键

- 多对多

例如：一个学生可以选修多门课程，一门课程也可以供多个学生选择

实现方式：建立第三张表，中间表至少包含两个外键，分别关联两方主键

样例：例如学生表和课程表外可以建立学生课程关系表（第三张表）来关联前两张表

- 一对一

例如：一对一关系，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率

实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（unique）

### 多表查询概述

- 笛卡尔积：笛卡尔积是指在数学中两个集合A和B的所有组合情况（在多表查询时，需要消除无效的笛卡尔积）

- 多表查询分类
  - 连接查询
    - 内连接：查询两张表交集部分的数据
    - 外连接：
      - 左外连接：查询左表所有数据以及两张表交集部分数据
      - 右外连接：查询右表所有数据以及两张表交集部分数据
    - 自连接：当前表与自身的连接查询，自连接必须使用表别名
  - 子查询

> 注意：连接的分类关键点在于查询二字，不同的连接查询的内容不一样，但是所返回的内容均是所有字段（相同的字段名只出现一次，除非select中重新提及）

### 内连接

内连接查询语法

- 隐式内连接

```mysql
select 字段列表 from 表1,表2 where 条件...
```

> 注意：只有带有where 条件的查询才是隐式内连接，如果不带条件则为笛卡尔积

- 显式内连接

```mysql
select 字段列表 from 表1 [inner] join 表2 on 条件...
```

> 上面的on可以替换为using，using的用法为using(相同的列名1,相同列名2...)
>
> using(相同的列名A,相同列名B...)等价于
>
> on 表1.列名A=表2.列名A and 表2.列名B=表2.列名B

### 外连接

外连接查询语法

- 左外连接

查询左表所有数据以及两张表交集部分数据

```mysql
select 字段列表 from 表1 left [outer] join 表2 on 条件...
```

- 右外连接

查询右表所有数据以及两张表交集部分数据

```mysql
select 字段列表 from 表1 right [outer] join 表2 on 条件...
```

### 自连接

查询语法

```
select 字段列表 from 表A 别名A join 表A 别名B on 条件...
```

> 自连接查询可以是内连接查询也可以是外连接查询，上方语法以内连接为例

### 联合查询-union，union all

与自连接不同，union查询就是把多次查询的记录合并起来，形成一个新的查询结果集

```
select 字段列表 from 表A...
union [all]
select 字段列表 from 表B...;
```

> 注意：union相当于直接将两次查询的结果集合并起来，并非进行连接操作

### 子查询

概念：SQL语句中嵌套select语句，称为嵌套查询，又称子查询

```
select 字段列表 from 表 where 表中某字段=(select 表中某字段 from t);
```

> 子查询的外部语句可以是insert/update/delete/select中的任何一个

- 根据查询结果不同，分为：
  - 标量子查询（子查询结果为单个值）
  - 列子查询（子查询结果为一列，可以多行）
  - 行子查询（子查询结果为一行，可以多列）
  - 表子查询（子查询结果为多行多列）

- 标量子查询

```mysql
常用操作符：= <> > >= < <=
```

- 列子查询

```
常用操作符：in、not in、any、some、all
```

> 注意：any和some等同，两者可以互相使用

- 行子查询

```
常用操作符：=、<>、in、not in
```

- 表子查询

```mysql
常用操作符示例：in 元组 (表子查询)
```



## 事务

###  事务简介

事物是一组操作的集合，它是一个不可分割的工作单位，事物会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败

每条DML语句被视为一项事务，如果事务没有被提交则不会修改数据库中的内容

>  默认情况下MySQL的事务是自动提交和回滚的，也就是说，当执行一条DML语句，MySQL会立即隐式的提交事务

### 事务操作

- 查看/设置事务提交方式

```
select @@autocommit;	// 查看当前事务的提交方式，1为自动提交，0为手动提交
set @@autocommit = 0;	// 关闭事务的自动提交，设置为手动提交
```

- 提交事务

```
commit;		// 提交事务
```

- 回滚事务

```
rollback;	//
```

- 开启事务

```
start transaction 或 begin;
```

> 如果要实现实现出现异常时自动回滚则需要利用存储过程相关的知识

### 事务四大特性

- 原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败
- 一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态
- 隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行
- 持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的

### 并发事务所引发的问题

|    问题    |                             描述                             |
| :--------: | :----------------------------------------------------------: |
|    脏读    |           一个事务读到另外一个事务还没有提交的数据           |
| 不可重复读 | 一个事务先后读取同一条记录，但两次读取的数据不同，称为不可重复读 |
|    幻读    | 一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在 |

> 解决这些问题可以利用事务的隔离级别

### 事务隔离级别

|           隔离级别           | 脏读 | 不可重复读 | 幻读 |
| :--------------------------: | :--: | :--------: | :--: |
|       Read uncommitted       |  √   |     √      |  √   |
| Read committed（Oracle默认） |  ×   |     √      |  √   |
| Repeatable Read（MySQL默认） |  ×   |     ×      |  √   |
|         Serializable         |  ×   |     ×      |  ×   |

> 从上到下隔离级别越高，数据越安全，但是相应的性能越来越差

> 注意：repeatable read下，为了维护可重复读的特性，因此无论并发事务如何重复修改内容，如果执行同一个原有查询事务则不会得到修改后的内容，而是会返回原本的内容，但是当插入的时候如果原有id（或其他主键）相同则会报错

- 查看事务的隔离级别

```mysql
select @@transaction_isolation
```

- 设置事务隔离级别

```
set [session | global] transaction isolation level {read uncommentted | read committed | repeatable Read | serializable}
```

> session  会话级别，仅针对当前客户端窗口有效
>
> global	 针对所有客户端窗口有效

# MySQL进阶

## 存储引擎

### MySQL体系结构

![image-20220319234051296](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220319234051296.png)

> 索引是在引擎层中存储的

- 连接层

最上层是一些客户端和链接服务，主要完成一些类似于连接处理，授权认证及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限

- 服务层

第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。

所有跨存储引擎的功能也在这一层实现，如过程，函数

- 引擎层

存储引擎真正地负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎

- 存储层

主要是将数据存储在文件系统之上，并完成与存储引擎的交互

### 存储引擎简介

存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也可被称为表类型

mysql5.5版本后默认存储引擎为innoDB

- 创建表时指定存储引擎

```
create table 表名(
	字段1 字段1类型 [comment 字段1注释],
	...
	字段n 字段n类型 [comment 字段1注释],
)engine=innodb [comment 表注释];
```

- 查询当前数据库支持的存储引擎

```
show engines;
```



### 存储引擎特点

#### innoDB

- 介绍
  - innoDB是一种兼顾高可靠性和高性能的通用存储引擎，在MySQL5.5之后，innoDB是默认的MySQL存储引擎

- 特点

  - DML操作遵循ACID模型，支持事务

  - 行级锁，提高并发访问性能

  - 支持外键foreign key约束，保证数据的完整性和正确性

- 文件
  - xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引

参数：innodb_file_per_table

<img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220320130441106.png" alt="image-20220320130441106" style="zoom:150%;" />

#### MylSAN

- 介绍
  - MylSAM是MySQL早期的默认存储引擎

- 特点
  - 不支持事物，不支持外键
  - 支持表锁，不支持行锁
  - 访问速度快
- 文件
  - xxx.sdi：存储表结构信息
  - xxx.MYD：存储数据
  - xxx.MYI：存储索引

#### Memory

- 介绍
  - Memory引擎的表数据是存储在内存中的，由于受到硬件问题或断电问题的影响，只能将这些表作为临时表或缓存使用
- 特点
  - 内存存放
  - hash索引（默认）
- 文件
  - xxx.sdi：存储表结构信息

#### 三大常用存储引擎特点总结

|     特点     |       InnoDB        | MylSAM | Memory |
| :----------: | :-----------------: | :----: | :----: |
|   存储限制   |        64TB         |   有   |   有   |
|   事务安全   |        支持         |   -    |   -    |
|    锁机制    |        行锁         |  表锁  |  表锁  |
|  B+tree索引  |        支持         |  支持  |  支持  |
|   Hash索引   |          -          |   -    |  支持  |
|   全文索引   | 支持（5.6版本之后） |  支持  |   -    |
|   空间使用   |         高          |   低   |  N/A   |
|   内存使用   |         高          |   低   |  中等  |
| 批量插入速度 |         低          |   高   |   高   |
|   支持外键   |        支持         |   -    |   -    |

### 存储引擎选择

在选择存储引擎时，应根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合

- innoDB：是MySQL的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择
- MylSAM：如果应用以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么应该选择MylSAM引擎
- MEMORY：将所有数据保存在内存中，访问速度快，通常用语临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性

## 索引

### 索引概述

- 介绍

索引（index）是帮助MySQL高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引

- 优缺点

|                            优势                             |                       劣势                       |
| :---------------------------------------------------------: | :----------------------------------------------: |
|           提高数据检索的效率，降低数据库的IO成本            |              索引列也是要占用空间的              |
| 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗 | 索引大大提高了查询效率，同时却也降低更新表的速度 |

### 索引结构

|       索引结构        |                             描述                             |
| :-------------------: | :----------------------------------------------------------: |
|      B+Tree索引       |         最常见的索引类型，大部分引擎都支持B+Tree索引         |
|       Hash索引        | 底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才有效，不支持范围查询 |
|  R-Tree（空间索引）   | 空间索引是MylSAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少 |
| Full-text（全文索引） |          是一种通过建立倒排索引，快速匹配文档的方式          |

> 我们平常说的索引，如果没有特别提出的话，一般指B+Tree索引

- 为什么InnoDB存储引擎选择使用B+Tree索引结构
  - 相对于二叉树，层级更少，搜索效率高
  - 对于BTree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量的数据，只能增加树的高度，导致性能降低
  - 相对于Hash索引，B+Tree支持范围匹配及排序操作

### 索引分类

|   分类   |                         含义                         |           特点           |  关键词  |
| :------: | :--------------------------------------------------: | :----------------------: | :------: |
| 主键索引 |               针对于表中主键创建的索引               | 默认自动创建，只能有一个 | PRIMARY  |
| 唯一索引 |           避免同一个表中某数据列中的值重复           |        可以有多个        |  UNIQUE  |
| 常规索引 |                   快速定位特定数据                   |        可以有多个        |          |
| 全文索引 | 全文索引查找的是文本中的关键词，而不是比较索引中的值 |        可以有多个        | FULLTEXT |

在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：

|            分类             |                             含义                             |         特点         |
| :-------------------------: | :----------------------------------------------------------: | :------------------: |
| 聚集索引（clustered index） | 将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据（叶子节点的唯一子节点为行数据） | 必须有，而且只有一个 |
| 二级索引（secondary index） | 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键（叶子节点的子节点为主键） |     可以存在多个     |

聚集索引选取规则：

- 如果存在主键，主键索引就是聚集索引
- 如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引
- 如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引

### 索引语法

- 创建索引

```mysql
create [unique | fulltext] index index_name on table_name(index_col_name,...);
```

> 注意：如果在index之前不加任何关键式则为创建常规索引

> 注意：创建索引的时候创建列的顺序是有讲究的，不能随意选取

> 一个索引可以关联多个字段
>
> 关联单个字段的索引被称为单列索引
>
> 关联多个字段的索引被称为联合索引或组合索引

- 查看索引

```mysql
show index from table_name;
```



- 删除索引

```mysql
drop index index_name on table_name;
```



### SQL性能分析

- 查询SQL执行频率

MySQL客户端连接成功后，通过 `show [session | global] status` 命令可以提供服务器状态信息。通过如下指令查看当前数据库增删改查的访问频次：

```mysql
show global status like 'Com_%';
```

- 慢查询日志

慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。

可以通过如下指令查询windows下慢查询日志开关的开启情况

```mysql
show variables like '%quer%'	# 返回值为on/off
```

可以通过如下指令查询linux下慢查询日志开关的开启情况

```mysql
show variables like 'slow_query_log';
```

MySQL的慢查询日志默认没有开启，需要修改Mysql的配置文件

windows下在my.ini文件中的[mysqld]后面添加如下信息

```mysql
[mysqld]
# 代表MySQL慢查询的日志存储目录，此目录文件一定要有写权限
log-slow-queries="慢查询日志存储位置（绝对路径）"
# 指定最长执行时间
long_query_time = 4
# 没有使用到索引的查询也将被记录在日志中
log-queries-not-using-indexes
```

linux下在(/etc/my.cnf)中配置如下信息：

```mysql
# 开启MySQL慢日志查询开关
slow_query_log=1
# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志
long_query_time=2
```

- profile详情

show profiles能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling参数，能够看到当前MySQL是否支持profile操作

```
select @@have_profiling;
```

默认profiling是关闭的，可以通过set语句在session/global级别开启profiling

```mysql
set profiling = 1;
```

执行一系列的业务SQL操作，然后通过如下指令查看指令的运行耗时

```mysql
# 查看每一条SQL的耗时基本情况
show profiles;

# 查看指定query_id的SQL语句各个阶段的耗时情况
show profile for query query_id;

# 查看指定query_id的SQL语句CPU的使用情况
show profile cpu for query query_id;
```

> query_id可以通过 `show profiles` 指令查询

- explain执行计划

> 上述三种方式只是粗略地进行判定，并不能真正地评估一条SQL语句的性能，真正评估SQL的性能需要依靠explain语句

explain或desc命令获取MySQL如何执行select语句的信息，包括在select语句执行过程中表如何连接和连接的顺序

语法：

```mysql
# 直接在select语句之前加上关键字explain/desc
explain select 字段列表 from 表名 where 条件;
```

explain执行计划各字段含义

- id

  - select查询的序列号，表示查询中执行select子句或者是操作表的顺序（id相同，执行顺序从上到下，id不同，值越大，越先执行）

  - > 注意：该id并非自增，而是相当于表示一个权重

- select_type

  - 表示select的类型，常见的取值有simple（简单表，即不使用表连接或者子查询）、primary（主查询，即外层的查询）、union（union中的第二个或者后面的查询语句）、subquery（select/where之后包含了子查询）等

- type

  - 表示连接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、index、all

  - > - NULL表示不访问任何表
    > - system表示访问系统表
    > - const表示根据主键或者唯一索引进行访问
    > - ref表示使用非唯一性的索引进行查询
    > - index表示用了索引，但是会遍历整个索引树
    > - all表示全表扫描

- possible_key

  - 显示可能应用在这张表上的索引，一个或多个

- key

  - 实际使用的索引，如果为NULL，则没有使用索引

- key_len

  - 表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好

- row

  - MySQL认为必须要执行查询的行数，在innoDB引擎的表中，是一个估计值，可能并不总是精确的

- filtered

  - 表示返回结果的行数占需读取行数的百分比，filtered的值越大越好

### 索引使用的原则

#### 索引失效的情况及其优化方式

- 最左前缀法则

如果索引了多列（联合索引），则要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不能跳过索引中的列。如果跳跃了某一列，索引将部分失效（后面的字段索引失效）

> 即在where中的查询条件需要符合索引的字段，字段查询顺序可以不一样，但最左边的字段必须存在，否则索引将会失效

- 范围查询

联合索引中，出现范围查询(>,<)，范围查询右侧的列索引失效

例如下方的查询关键字中，假设存在该索引，则status索引将会失效

```mysql
where age > 30 and status = '0'
```

> 规避方法：尽量使用>=或<=这样的查询语句

- 索引列运算

不要在索引列上进行运算操作（例如使用substring函数），否则将会失效

- 字符串不加引号

字符串类型字段使用时，不加引号，索引将失效

- 模糊查询

如果仅仅是尾部模糊匹配，索引不会失效，如果是头部模糊匹配，索引失效

- or连接的条件

用or分隔开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到

> 解决方法：将后面的列也建立索引

- 数据分布影响

如果MySQL评估使用索引比全表更慢，则不使用索引

#### SQL提示

SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的

- use index
  - 建议数据库用哪个索引，数据库最终不一定执行该索引
- ignore index
  - 让数据库忽略哪个索引，数据库一定会忽略该索引
- force index
  - 强制数据库使用哪个索引

语法

```mysql
select 字段 from 表名 [use/ignore/force index(索引名)] where 条件;
```

#### 覆盖索引

在查询时尽量使用覆盖索引，减少使用 `select *`

> 覆盖索引：覆盖索引指在查询时使用了索引，并且select需要返回的列在该索引中已经全部能够找到，具体索引返回的字段详见聚集索引和二级索引部分

> extra中的提示：
>
> ​	using index condition：查找使用了索引，但是需要回表查询数据
>
> ​	using where;using index：查找使用了索引，但是需要的数据在索引中能找到，所以不需要回表查询数据

#### 前缀索引

当字段类型为字符串（varchar，text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时浪费大量的磁盘IO，影响查询效率。

> 优化方式：只将字符串的一部分前缀建立索引，这样可以大大节约索引空间，从而提高索引效率

创建前缀索引的语法：

```mysql
create index idx_xxxx on table_name(column(n));
```

> 注意：idx_xxxx实际上仍是索引名，只是一种命名规则，重要的是column后面的n为字符串前缀长度

前缀长度：

可以根据索引的选择性来决定

> 索引选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择值越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的

- 单列索引和联合索引

单列索引：一个索引只包含单个列

联合索引：一个索引包含了多个列

> 在业务场景中，如果存在多个查询条件，考虑针对查询字段建立索引时，建议建立联合索引，尽量减少回表查询

### 索引设计原则

1. 针对数据量较大(一般要超过一百多万)且查询比较频繁的表建立索引
2. 针对于常作为查询条件(where)、排序(order by)、分组(group by)操作的字段建立索引
3. 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的频率越高
4. 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点建立前缀索引
5. 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率
6. 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改查的效率
7. 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，他可以更好地确定哪个索引最有效地用于查询



## SQL优化

### 插入数据

- insert优化

1. 尽量批量插入，避免多次单词插入，且批量插入的数据尽量在一千条以内
2. 尽量在使用多条insert时使用手动事务提交
3. 尽量将主键按照顺序插入，顺序插入性能大于乱序插入

- 大批量数据插入

如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令进行插入。操作如下

```mysql
# 客户端连接服务端时，加上参数 --local-infile
mysql --local-infile -u root -p
# 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关
set global local_infile=1;
# 执行load指令将准备好的数据加载到表结构中
load data local infile '文件存放路径' into table 表名 fields terminated by '数据字段分隔符，如,' lines terminated by '行分隔符，如\n'
```

> 注意：需要插入的大批量数据需要有相同的结构，如使用逗号进行分隔不同的数据段

### 主键优化

- 数据组织方式

在innoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表(index organized table,IOT)

- 主键设计原则

1. 满足业务需求的情况下，尽量降低主键的长度
2. 插入数据时，尽量选择顺序插入，选择使用auto_increment自增主键
3. 尽量不要使用UUID(唯一通用识别码)或者是其他自然主键做主键，如身份证号
4. 业务操作时，尽量避免对主键的修改

### order by优化

- 知识点

1. using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序，所有不是通过索引直接返回排序结果的排序都叫Filesort排序
2. using index：通过有序索引顺序扫描直接返回有序数组，这种情况即为using index，不需要额外排序，操作效率高

> 尽量将order by优化为using index

> 索引如无特殊声明，一般只能用于全部升序或者全部降序的情况，如果一个升序一个降序，则可以创建一个新的索引来提高效率

```mysql
create index 索引名 on 表名(字段1 asc,字段2 desc)
```

- 优化方式

1. 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则
2. 尽量使用覆盖索引
3. 多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）
4. 如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size（默认256K）

### group by优化

建立索引进行优化

### limit优化

覆盖索引+子查询的形式优化

例如：

```
explain select * from tb_sku t,(select id from tb_sku order by id limit 20000000,10) a where t.id = a.id
```

### count优化

count函数能够统计行数或者某一字段中不为null的值的总数

> 注意：count(1)也是统计行数

> MylSAM引擎把一张表的总行数存在了磁盘上，因此执行count(*)时就会直接返回这个数，查询效率高
>
> innoDB引擎执行count(*)的时候需要把数据一行一行地从引擎里读出来然后累计计数，查询效率低

优化思路：自己计数

> 注意：count(*)和count(1)均不取值，直接返回行数，因此性能最高

### update优化

在使用update时，在没有提交事务时，如果where后面的查询字段是索引，则会有一个行锁，将整行锁掉，如果where后面的字段没有索引，则会升级为表锁

因此，在使用update语句时，一定要使用索引进行更新（即where后的查询条件要为索引），否则行锁会升级为表锁，从而锁住整张表，导致并发性能降低

> innoDB的行锁是针对索引加的所，不是针对记录加的锁，并且该索引不能失效，否则也会从行锁升级为表锁

## 视图/存储过程/触发器

### 视图

- 介绍

视图是一种虚拟存在的表，视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的

简单来说，视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建SQL查询语句上

- 创建视图

```mysql
create [or replace] view 视图名称(列名列表) as
select ...	# 所要封装的句子
[with [cascaded | local] check option]
```

> 列名列表可以不填

- 视图的检查选项

[with [cascaded | local] check option] 为语句检查，默认为cascaded，如果在创建视图时加入此选项，则会检查所插入/更新/删除的数据是否满足where中的要求，如果不填，如果不符合要求的数据也会被插入表中（表中的数据会改变）但无法被该视图查询

cascaded与local的区别在于local指检查当前视图是否满足当前视图的选取规则，而不会检查底层视图的选取规则（底层视图定义为衍生当前视图的视图，即当前视图如果是在另一张视图的基础上生成的，则另一张视图称为底层视图）

- 查询视图

```
show create view 视图名称;	# 查看创建视图语句
select * from 视图名称 where......;	# 查看视图数据，直接将视图当做表查询即可
```

- 修改视图

```mysql
# 方法一，即创建视图时所用的语句
create or replace view 视图名称(列名列表) as
select ...	# 所要封装的句子
[with [cascaded | local] check option]
# 方法二
alter view 视图名称[(列名列表)] as
select ...	# 所要封装的句子
[with [cascaded | local] check option]
```

> 列名列表可以不填

- 删除视图

```mysql
drop view [if exists] 视图名称1[,视图名称2...]
```

> 可以一次性删除多张视图

- 视图的更新

要使视图可以更新，视图中的行与基础表中的行之间必须存在一对一的关系，如果视图包含以下任意一项，则视图不可更新

1. 聚合函数或窗口函数（SUM()、MIN()、MAX()、COUNT()等)
2. distinct
3. group by
4. having
5. union 或者 union all

- 视图的作用
  - 操作简单
    - 视图不仅可以简化用户对数据的理解，也可以简化他们的操作，那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件
  - 安全
    - 数据库可以授权，但不能授权到数据库特定行和特定列中，而通过视图用户只能查询和修改他们所能见到的数据
  - 数据独立
    - 视图可以帮助用户屏蔽真实表结构变化带来的影响（例如表中某列名称产生变化，则可以通过视图列别名的方式规避因变化而带来的影响）

### 存储过程

#### 存储过程

- 介绍

存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的

储存过程思想上很简单，就是数据库SQL语言层面的代码封装与重用

- 特点

1. 封装、复用
2. 可以接受参数，也可以返回数据
3. 减少网络交互，提升效率

- 创建存储过程

```mysql
delimiter $$
create procedure 存储过程名称([ 参数列表 ])
[characteristics...]
begin
	...		# SQL语句
end$$
delimiter ;

# characteristics表示创建存储过程时指定的对存储过程的约束条件，一般不写，其部分取值信息如下：
# deterministic		# 相同的输入参数总是产生相同的结果
# no sql			# 不包含SQL语句
#reads sql data		# 包含读取数据的语句，但不包含写入数据的语句
```

> 注意：在命令行中，在执行创建存储过程的SQL时，需要通过关键字delimiter指定SQL语句的结束符

- 调用存储过程

```mysql
call 存储过程名称([ 参数 ])
```

- 查看存储过程

```mysql
select * from information_schema.routines where routine_schema='xxx'; # 查询指定数据库的存储过程及状态信息，'xxx'中为需要查询的数据库名称
show create procedure 存储过程名称; # 查询某个存储过程的定义
```

- 删除存储过程

```mysql
drop procedure [if exists] 存储过程名称;
```

#### 变量

- 系统变量

系统变量是MySQL服务器提供的，不是用户定义的，属于服务器层面。分为全局变量(GLOBAL)、会话变量(SESSION)

> 全局变量针对所有会话有效，注意，如果服务器重启后所设置的全局变量也会失效，如果想要永久修改，则需要在etc/my.cnf文件中配置
>
> 会话变量仅针对当前会话有效

- 查看系统变量

```mysql
show [session | global] variables;	# 查看所有系统变量
show [session | global] variables like '...'; # 可以通过like模糊匹配方式查找变量
select @@[session | global]系统变量名;	# 查看指定变量的值
```

> 查询系统变量时如果不指定global，则查询的是session级别的变量

- 设置系统变量

```mysql
set [session | global] 系统变量名=值;
set @@[session | global]系统变量名=值;
```

- 用户自定义变量

用户自定义变量是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用 `@变量名` 的方式即可直接使用，其作用域为当前会话

> 如果直接使用未声明的变量也不会报错，而是会返回null

- 用户自定义变量赋值

```mysql
set @var_name1=expr1[,@var_name2=expr2...];
set @var_name1:=expr1[,@var_name2:=expr2...];
select @var_name1:=expr1[,@var_name2:=expr2...];
select 字段名 into @var_name from 表名;
```

> 推荐使用:=而不是=进行赋值，避免与=（比较运算符）产生歧义

- 用户自定义变量的使用

```mysql
select @var_name;
```

- 局部变量

局部变量是根据需要定义在局部生效的变量，访问之前需要使用declare进行声明。

局部变量可以在存储过程内部进行声明和使用，也可以作为输入参数进行使用

局部变量的范围是在其内声明的begin...end块区域中

- 局部变量声明

```mysql
declare 变量名 变量类型 [default 变量值];
```

> 变量类型就是数据库字段类型，int、bigint、char、varchar、date、time等

- 局部变量赋值

```
set 变量名=值;
set 变量名:=值;
select 字段名 into 变量名 from 表名...;
```

#### 游标

游标（CURSOR）是用来存储查询结果集的数据类型，在存储过程和函数中可以使用游标对结果集进行循环的处理。

游标的使用包括游标的声明、open、fetch、close，其语法分别如下

- 声明游标

```mysql
declare 游标名称 cursor for 查询语句;
```

> 游标要在普通变量声明结束后才能声明，否则会报错

- 打开游标

```mysql
open 游标名称;
```

> 在使用游标之前一定要打开游标才能从其中获取数据

- 获取游标记录

```mysql
fetch 游标名称 into 变量[,变量...];
```

> 后面的变量需要对应游标中的字段

- 关闭游标

```mysql
close 游标名称;
```

#### 条件判断语句

- 条件判断if

语法：

```mysql
if 条件1 then
	...
elseif 条件2 then
	...
else
	...
end if;
```

> if语句中then后面为sql语句，以;号进行结尾

- case

语法一：

```mysql
case 表达式
	when 条件1 then 语句列表1
	when 条件2 then 语句列表2
	else 语句列表
end case;
```

语法二：

```mysql
case
	when 条件1 then 语句列表1
	when 条件2 then 语句列表2
	else 语句列表
end case;
```

#### 循环语句

- while

while循环是有条件的循环控制语句。满足条件后，再执行循环体中的SQL语句

具体语法为：

```mysql
while 条件 do
	...	# SQL语句
end while;
```

- repeat

repeat是有条件的循环控制语句，当满足条件的时候退出循环。具体语法为：

```mysql
# 限制性一个逻辑，然后判断逻辑是否满足，如果满足，则退出，如果不满足，则继续。类似其他语言的do...while
repeat
	...	# SQL语句
	until 条件
end repeat;
```

- loop

loop实现简单的循环，如果不再SQL逻辑中增加退出循环的条件，可以用其来实现简单的死循环。

loop一般配合以下两个语句使用

```mysql
leave	# 配合循环使用，作用是退出循环
iterate	# 必须用在循环中。作用是跳过当前循环剩下的语句，直接进入下一次循环
```

```
[begin_label:]loop
	...	# SQL逻辑
end loop [end_label];
```

```
leave label;	# 退出指定标记的循环体
iterate label;	# 直接进入下一次循环
```

> loop可以设置标记来标志这次的循环名称，并利用该标记对循环进行操作

#### 条件处理程序

条件处理程序(handler)一般用于存储过程内部，条件处理程序可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。

条件处理程序的声明位置在游标下面

具体语法为：

```mysql
declare handler_action  handler for condition_value1[,condition_value1...] 在执行handler之前需要执行的语句;
```

> 参数说明：
>
> ​	handler_action
>
> ​					continue	# 继续执行当前程序
>
> ​					exit			 # 终止执行当前程序
>
> ​	condition_value
>
> ​					sqlstate sqlstate_value	# 状态码，如02000
>
> ​					sqlarning							# 所有以01开头的sqlstate代码的简写
>
> ​					not found						   # 所有以02开头的sqlstate代码的简写
>
> ​					sqlexception					  # 所有没有被sqlwarning或not found捕获的状态码的简写

> 关于各种状态码的含义，可以参考SQL官方文档

#### 存储过程的参数

| 类型  |                      含义                      | 备注 |
| :---: | :--------------------------------------------: | :--: |
|  in   |    该类参数作为输入，也就是需要调用时传入值    | 默认 |
|  out  |  该类参数作为输出，也就是该参数可以作为返回值  |      |
| inout | 该类参数既可以作为输入参数，也可以作为输出参数 |      |

用法：

```mysql
create procedure 存储过程名称([in/out/inout] 参数名 参数类型)
begin
	...	#SQL语句
end;
```

> 存储过程的参数可以是多个，使用,号进行分隔
>
> 无论是输入参数还是输出参数，均在同一个地方进行声明，且对于out和inout参数，需要使用用户自定义变量作为输出参数的实参

### 存储函数

存储函数是有返回值的存储过程，存储函数的参数只能是in类型的

能够使用存储函数的地方均能够使用存储过程进行替代

具体的语法如下：

```mysql
create function 存储函数名称([ 参数列表 ])
returns type [characteristic...]	# 指定返回值的类型和特性
begin
	SQL语句
	return ...;
end;

characteristic代表返回值的特性，与存储过程用法一致，可选值：
deterministic	# 相同的输入参数总是产生相同的结果
no sql			# 不包含SQL语句
reads sql data	# 包含读取数据的语句，但不包含写入数据的语句
```

### 触发器

- 介绍

触发器是与表有关的数据库对象，指在insert/update/dalete之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特点可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作

mysql中的触发器使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他数据库是相似的。

现在mysql中的触发器还只支持行级触发，不支持语句级触发

> 注意：触发器中不允许直接输出select中的内容

|   触发器类型   |                      NEW和OLD                      |
| :------------: | :------------------------------------------------: |
| insert型触发器 |            new表示将要或已经增加的数据             |
| update型触发器 | old表示修改之前的数据，new表示将要或已经修改的数据 |
| delete型触发器 |            old表示将要或已经删除的数据             |

- 创建触发器

```mysql
create trigger trigger_name
before/after insert/update/delete
on table_name for each row		# 行级触发器
begin
	触发器触发的内容;
end;
```

- 查看触发器

```
show triggers;
```

- 删除触发器

```mysql
drop trigger [schema_name]trigger_name;	# 如果没有指定schema_name，默认为当前数据库
```



## 锁

## InnoDB核心

## MySql管理



# MySQL运维

## 日志

## 主从复制

## 分库分表

## 读写分离