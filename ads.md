单词：

exceed			溢出

accommodate	容纳

induce			引起，导致

descendant		后代

inverted			颠倒

compact			压缩

# 目录

[1. AVL树	](#_Toc2379 )

[1.1. 基本思想	](#_Toc32282 )

[1.2. 实现原理	](#_Toc12634 )

[1.3. 高度平衡（height balanced）	](#_Toc8829 )

[1.4. 平衡因子	](#_Toc11934 )

[1.5. 旋转规则	](#_Toc11024 )

[1.5.1. LL	](#_Toc21740 )

[1.5.2. RR	](#_Toc13489 )

[1.5.3. LR	](#_Toc3206 )

[1.5.4. RL	](#_Toc12817 )

[1.6. 高度平衡树的最少节点数	](#_Toc17152 )

[1.7. 删除节点	](#_Toc12657 )

[2. Splay树	](#_Toc20627 )

[2.1. 基本思想	](#_Toc2362 )

[2.2. 实现原理	](#_Toc23761 )

[2.3. 旋转规则	](#_Toc27224 )

[3. 平摊分析（Amortized Analysis）	](#_Toc26124 )

[3.1. 什么是平摊分析	](#_Toc3721 )

[3.2. 平摊分析之聚合分析（Aggregate Analysis）	](#_Toc26869 )

[3.2.1. 思想	](#_Toc10746 )

[3.2.2. 样例	](#_Toc21055 )

[3.3. 平摊分析之会计分析（Accounting Analysis）	](#_Toc17125 )

[3.3.1. 思想	](#_Toc29256 )

[3.3.2. 样例	](#_Toc26384 )

[3.4. 平摊分析之势能分析（Potential method）（待补充）	](#_Toc11029 )

[3.4.1. 思想	](#_Toc13918 )

[3.4.2. 样例	](#_Toc4902 )

[3.5. 聚合分析和会计分析的区别	](#_Toc13013 )

 



 

# 1. AVL树

AVL树是每次访问平均时间复杂度为O(logN)的算法 

## 1.1. 基本思想

AVL树又称为高度平衡的二叉搜索树。它能保持二叉树的高度平衡，尽量降低二叉树的高度，减少树的平均搜索长度，是二叉搜索树的一种改进算法。

## 1.2. 实现原理

通过一定的旋转规则使得二叉搜索树始终保持着高度平衡状态，具体旋转规则见下

## 1.3. 高度平衡（height balanced）

定义规则：

1.规定一颗空树是高度平衡的树。

2.如果T是一颗非空的树，TL和TR是他的左子树和右子树，则如果T是一颗高度平衡的树需要满足以下两个条件：

1）TL和TR是高度平衡的

2）平衡因子的绝对值（| hL-hR |）<=1，其中hL和hR分别是TL和TR的高度

## 1.4. 平衡因子

每个节点的平衡因子被定义为该节点的左子树的高度减去右子树的高度

即BF(node) = hL-hR 在一棵AVL树中，BF(node)= -1,0,1

## 1.5. 旋转规则

AVL树当且仅当检测到某一节点的平衡因子出错时进行旋转，令该节点为X

令插入的键值为key

### 1.5.1. LL

如果key小于节点X的左子树的键值，则进行右旋

### 1.5.2. RR

如果key小于X的右子树的键值，则进行左旋

### 1.5.3. LR

如果key大于左子树的键值，则先对左子树进行左旋，再对节点X进行右旋

### 1.5.4. RL

如果key大于右子树的键值，则右子树进行右旋，再对节点X进行左旋

## 1.6. 高度平衡树的最少节点数

令Nh为高度为 h的高度平衡树的最少节点数，h>0

Nh=Nh-1+Nh-2+1时，高度平衡树所需的节点数最少，此时左右子树高度不同

高度平衡数最少节点数的结论：

Nh=F(h+2)-1，F(x)为斐波那契数列(F(0)=0,F(1)=1,F(i)=F(i-1)+F(i-2))，

由于 ![img](file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml\wps9B96.tmp.png) 则 ![img](file:///C:\Users\ASUS\AppData\Local\Temp\ksohtml\wps9B97.tmp.png)

## 1.7. 删除节点

同二叉搜索树，即遵循以下步骤（以删除X节点为例）：

1.找到X节点

2.删除X节点

3.找到X节点的左子树的最大值，设为Y

4.用节点Y代替原先X节点的位置，即成为新的根

# 2. Splay树

M次操作的时间复杂度为O(MlogN)的算法

## 2.1. 基本思想

伸展树的基本想法是，当一个节点被访问后，它要经过一系列AVL树的旋转操作，被放置到根上。如果该节点很深，那么我们必须通过重构使这些节点的访问花费的时间也变少。

即伸展树的想法是把访问过的节点尽量的放到靠近根的地方。以便这些节点下一次被访问时，能快速的找到。原理来源于在实际应用中，很多情形下，一个节点被访问过后，在不久的将来，它就会迎来下一次访问。研究表明，这种情况发生的比我们想象的还更加频繁。

伸展树在理论上能给出M次连续对树的操作最多花费O(MlogN)的时间，注意，这里是给出了对M次连续操作的情形的保证，它并不保证一次操作不会出现O(N)这样的可能性。

伸展树不需要保存节点的高度信息，这样能够节省存储空间。

## 2.2. 实现原理

当查找节点X的时候，多次考虑该节点和其父亲节点P（因为每次旋转之后该节点的父亲节点会改变）。根据对应规则依次进行旋转，最后将节点X旋转至根的位置

## 2.3. 旋转规则

以访问节点X为例，假设节点P为节点X的当前父亲，节点G为X的当前爷爷

情况1

如果父亲P是根节点，则直接旋转P和X（旋转必须遵循二叉搜索树性质）

情况2

如果父亲P不是根节点，如果为Zig-zag则依次旋转P和X、G和X，如果为Zig-zig则绕着节点X做一次单旋

方式），重复进行情况1或情况2操作，直到X成为新的根节点

# 3. 平摊分析（Amortized Analysis）

## 3.1. 什么是平摊分析

1.平摊分析是指在某种数据结构上完成一系列操作，在最坏情况下所需的平均时间

2.平摊分析与传统分析方法的主要差别为：

1)平摊分析时间与传统分析方法的平均情况下时间不同，它是最坏情况下的平均		时间

2)平摊分析不涉及概率分析，即它只分析总体

3)平摊分析中时间函数T(n)，其中n指的是操作的次数，而不是输入的规模。

3.常见的有三种方法：聚集法、记账法、势能法。

 

## 3.2. 平摊分析之聚合分析（Aggregate Analysis）

### 3.2.1. 思想

聚合分析是把n个不同或相同的操作合在一起加以分析计算得到总时间的方法。即n个操作序列在最坏情况下的总时间，记为T(n)，其中n为操作数。由此得到在最坏情况下每个操作的平均时间为T(n)/n。

### 3.2.2. 样例

以push、pop和multipop操作为例

push操作所需时间为1，pop操作所需时间为1，multipop操作所需时间为min(sizeof(S),k)，其中S为栈中剩余元素，k为出栈次数

则由聚合分析的思想可得：由于pop操作和multipop操作均需由push次数决定，在最差情况下将进行n/2次push和n/2次multipop，则时间T=n，故每个操作的平摊时间为T(n)/n=O(1)

## 3.3. 平摊分析之会计分析（Accounting Analysis）

### 3.3.1. 思想

会计分析也称为记账分析，分析思想是先对每个不同的操作核定一个不同的费用（时间），然后计算n次操作总的费用。当然，由于这个费用是人为赋予的，所以很容易得到一个松上界。这种事先的操作费用核定可能与实际费用不符，存在二种情况：

1）超额收费：核定费用>实际费用，此时差额存放在该对象的身上。

2）收费不足：核定费用<实际费用，此时差额由该对象身上的存款支付。

费用的核定(平摊核定)是否正确需检查n次操作核定总费用是否大于n次操作实际总费用（这里n具有任意性，并不是单指一个定值n）。因此，在记账方法中，某些操作的费用比它们实际代价或多或少。

### 3.3.2. 样例

以push、pop和multipop操作为例

由于push操作决定了另外两种操作的操作次数，则可令push操作费用为+2，则pop和multipop操作的费用为0（该费用由push承担了），故平摊时间仍为O(1)

## 3.4. 平摊分析之势能分析（Potential method）

### 3.4.1. 思想

势能分析通过定义一个势能函数，用于评价数据结构某个状态的势能，把每个操作的时间复杂度加上操作导致的势能变化作为摊还复杂度，如果经过了一系列操作以后，势能不减少，这一系列操作的时间复杂度之和不大于这一系列操作的摊还复杂度之和。

第i个操作的摊还代价Ci’=Ci(第i个操作的实际代价)+当前数据结构的总势能-进行第i个操作之前的数据结构的总势能

则总摊还代价（即摊还复杂度）=所有操作的实际代价（实际时间复杂度）+进行所有操作后的数据结构总势能-原数据结构总势能。如果势能函数满足数据结构总势能-原数据结构总势能>=0，则总摊还代价是总实际代价的一个上界。

其中势能是由势能函数所求得的。而势能函数是由使用者根据实际情况所规定的

### 3.4.2. 样例

## 3.5. 聚合分析和会计分析的区别

 

# 4. 红黑树（Red-Black Trees）

## 4.1. 什么是红黑树

红黑树是一棵满足下列红黑属性的二叉搜索树：

1）每个节点要么是红的要么是黑的

2）根节点是黑的

3）每个叶节点是黑的（实操时通常引入空节点作为叶结点）

4）如果一个节点还是红的，那么他的孩子都是黑的

5）对于每个节点，从该节点到子代叶节点的所有的最短路径包含相同的黑节点数

## 4.2. 黑高（black-height）

任何节点x的黑高被定为bh(x)，黑高是从x（不包含x）到任意子代叶节点的黑节点的数量。其中bh(Tree) = bh(root)、

## 4.3. 红黑树添加时的调整规则

情况1：新节点即根节点

调整方法：将新节点直接变色为黑色

 

情况2：新节点的父节点是黑色

调整方法：将插入的新节点设为红色即可

 

情况3：新节点的父节点和叔节点都是红色

调整方法：将新节点的父节点和叔节点变为黑色，将新节点的祖父节点变为红色，使得局部满足红黑树规则，之后将祖父节点作为新节点依次检查上去，直到整棵树均满足红黑树规则

 

情况4：新节点的父节点是红色，叔节点是黑色或者没有叔节点，且祖父节点到新节点的关系为左右（父亲是祖父的左孩子，新节点是父亲的右孩子）

调整方法：以父节点为轴，做一次左旋，变为情况5，然后根据情况5进行处理即可

 

情况5：新节点的父节点是红色，叔节点是黑色或者没有叔节点，且祖父节点到新节点的关系为左左

调整方法：以祖父节点为轴，进行一次右旋，使原先的父节点成为祖父节点，然后将原来的祖父节点变为黑色，将原来的父节点变为红色



情况6（右左）为情况4的镜像，情况7（右右）为情况5的镜像

## 4.4. 红黑树删除时的调整规则

情况1：如果待删除节点有两个非空的孩子节点，转化成待删除节点只有一个孩子，或者没有孩子的情况

调整方法：用右子树中最小的节点替代待删除节点，并将该节点的颜色变成待删除节点的颜色，将原问题转化成情况2的问题

对于以下所有情况，均只讨论待删除节点只有一个右孩子节点或者无孩子节点的情况

情况2：如果待删除节点只有一个孩子或者没有孩子

调整方法：

2.1、如果待删除节点是红色，直接删除待删除节点即可

2.2、如果待删除节点是黑色，子节点是红色，则将待删除节点删除，并将子节点颜色改变成黑色

2.3、如果待删除节点是黑色，子节点也是黑色或者没有孩子，则转化为情况3的问题

 

情况3：父子双黑问题（待删除节点与其子节点均为黑色）

调整方法：

3.1、如果待删除节点是红黑树的根节点，则直接删除待删除节点即可（因为此处只讨论一个孩子的问题）

3.2、如果待删除节点的兄弟节点为黑色，则将该兄弟节点调整为红色，使得待删除节点的父节点的左右子树在删除调待删除节点后能够实现左右黑高相同，此时原待删除节点的父节点的黑高比原先少1，因而将该父节点视为新的待删除节点的子节点，依次往上递归操作

3.3、如果待删除节点的兄弟节点为红色，则待删除节点的父节点必定是黑色的，因而以待删除节点的父节点为轴，进行旋转，将原先的兄弟节点调整到原先待删除节点的父节点的位置，将原先的待删除节点的父节点移动到原先的待删除节点的位置，然后将原先的兄弟节点染成黑色，原先的待删除节点的父节点染成红色，之后删除待删除节点即可，此时仍不平衡（待删除节点删除后，这边的黑高仍会小1），需要之后根据情况3.4、3.5、3.6尝试再次平衡红黑树

3.4、待删除节点的父节点为红色，兄弟节点和侄子节点是黑色，则将父节点调整为黑色，兄弟节点调整为红色即可

3.5、待删除节点的父节点颜色随意，兄弟节点为黑色，兄弟节点的左孩子为红色，右孩子为黑色，则以兄弟节点为轴进行右旋，将原来的左侄子节点变为黑色，原来的兄弟节点变为红色，然后进行情况6操作

3.7、待删除节点的父节点颜色随意，兄弟节点为黑色，兄弟节点的左孩子是黑色的，右孩子是红色的，则以待删除节点的父节点进行旋转，使得原先的父节点调整到原先的待删除节点的位置，然后交换原先的父节点和原先的兄弟节点的颜色（如果父节点和兄弟节点的颜色不一样的话）

 

## 4.5. 红黑树与AVL树的区别

AVL树是严格平衡二叉树，要求每个节点的左右子树高度差不超过1，

红黑树条件更宽松一点，要求任何一条路径的长度不超过其他路径长度的两倍

AVL树的查找效率更高，平衡调整的成本更高

在频繁查找时应选用AVL树，在频繁插入删除时，应选用红黑树

 

# 5. B+树

## 5.1. 什么是B+树

一棵M阶的B+树满足下列的结构属性：

1、根节点要么是叶子，要么有2-M个孩子

2、所有的非叶节点（除了根节点）有M/2（M/2向上取整）到M个孩子

3、所有的叶节点都是在相同深度的

## 5.2. B+树的特点

B+树主要被应用于数据库的索引结构，B+树只有叶节点存放数据，其余节点只存放索引

## 5.3. B+树的添加

### B+树的添加

遵循分裂策略

最初当B+树是一棵空树时，根节点作为第一个叶子节点，在根节点中添加键值即可

当根节点中键值达到了M+1或，将其等分，将右子树的最小值作为键值，按照按照此策略依次进行后续添加

### B+树的删除

遵循分裂原则

当B+树删除叶子中的一个值时，如果该叶子中还有不少于2个值，则可无需进行任何操作

当删除后叶子只剩一个值，则将其合并至相邻叶子节点，然后按照添加规则进行修改，如果某一个节点只剩一个叶节点，则将该叶节点合并到相邻节点，并取消该节点的父亲

 

B+树中的key指的是叶子节点中容纳的数据数？？？

## 5.4. 2-3树易错点整理

1、当只有root一个节点时，root没有孩子

## 5.5. B+树的深度和查找的时间复杂度

Depth(M, N) = O(⌈log⌈M/2⌉ N⌉ )

TFind (M, N) = O( log N )

 

 

# 6. 颠倒文件索引（Inverted File Index）

## 6.1. 术语文档关联矩阵（Term-Document Incidence Matrix）

### 6.1.1. 实现方式

将文档依次编号，然后检索每一个属于是否出现在文档中，如果出现，则该矩阵对应值为1，如果未出现，则为0。如下表所示

|          | 1    | 2    | 3    | 4    |
| -------- | ---- | ---- | ---- | ---- |
| a        | 0    | 1    | 1    | 1    |
| arrived  | 0    | 0    | 1    | 1    |
| damaged  | 0    | 1    | 0    | 0    |
| delivery | 0    | 0    | 1    | 0    |

 

## 6.2. 术语文档关联矩阵紧凑版本——颠倒文件索引

### 6.2.1. 名词解释

索引：索引是一种在文本中定位给定术语的机制（mechanism）

倒排文件：倒排文件包含指向文本中该术语所有出现的指针列表（例如页数）。

 

### 6.2.2. 实现方式

将术语编号，并将术语作为关键词，记录下出现过该术语的文档和术语在所有文档中出现的次数（一个文档最多记一次次数），如下表所示

| No.  | Term     | Times; Documents |
| ---- | -------- | ---------------- |
| 1    | a        | <3; 2,3,4>       |
| 2    | arrived  | <2; 3,4>         |
| 3    | damaged  | <1; 2>           |
| 4    | delivery | <1; 3>           |
| 5    | fire     | <1; 2>           |

在用户输入关键词后，取所有关键词的文档交集，返回的文档编号即符合要求的文档

 

### 6.2.3. 优化方式

对于该方式，由于是取所有关键词的文档交集，可以采用优先检索出现频率少（即包含该关键词的文档数量少的关键词）的关键词的方法，可以有效增加检索速度

 

### 6.2.4. 索引生成算法

```
while ( read a document D ) {

  while ( read a term T in D ) {

	if ( Find( Dictionary, T ) == false )

		Insert( Dictionary, T );

		Get T’s posting list;

		Insert a node to T’s posting list;

  }

}

Write the inverted index to disk;
```



### 6.2.5. 存储索引的方式

```
BlockCnt = 0; 

while ( read a document D ) {

 while ( read a term T in D ) {

  if ( out of memory ) {

   Write BlockIndex[BlockCnt] to disk;

   BlockCnt ++;

   FreeMemory;

  }

  if ( Find( Dictionary, T ) == false )

   Insert( Dictionary, T );

  Get T’s posting list;

  Insert a node to T’s posting list;

 }

}
```

 

 

## 6.3. 读取术语后需要进行的操作

### 6.3.1. 单词提取（word stemming）

具体操作有：

1）将术语拆分成若干个单词

2）处理每个单词，使其只剩下词干或词根形式

### 6.3.2. 寻找停止词（stop word）

有些词非常常见，几乎每个文档都包含它们，例如“a”和“it”。为它们编制索引是无用的。它们被称为停止语。我们可以从原始文件中删除它们。

 

## 6.4. 分布式索引

### 6.4.1. 术语分割索引（Term-partitioned index）

将所有的术语按照首字母存储在不同的服务器上，需要检索的时候则先检索每一台服务器上的单词，然后进行归并运算

### 6.4.2. 文档分割索引（Document-partitioned index）

将文档按照一定的数量分别存放在各个服务器上，然后检索的时候搜索对应的服务器即可。即将文件号为一个范围内的文件存在一个节点上

 

## 6.5. 动态索引

### 6.5.1. 实现方式

随着时间的推移，文档逐渐加入，之后对加入的文档进行如下操作

1）对词典中已有的术语进行更新

2）加入原词典中未有的术语

如果文档被删除则将该文档做标记

### 6.5.2. 优化方式

1、可以利用主索引和辅助索引（auxiliary index）配合检索，主索引负责存储原有的索引，数据较难更改，辅助索引负责查找新的文档

2、关键词压缩：

将所有关键词去除停止词后压缩成一串字符串进行查找

3、优化倒排列表（Posting List）

即按照各个文档编号之间的关系存储文档编号，而非直接存储编号，这样避免了文档编号过大所带来的的空间开销

4、设置搜索引擎的搜索阈值（Thresholding）

1）对文档设置阈值

即仅仅检索并返回关联度最高的x篇文档

缺点：

由于截断，我们可能会错过一些相关文件

对于Boolean queries不可行

2）对查询设置阈值

即按频率升序对查询词进行排序或只根据原始查询词的某个百分比进行搜索

 

## 6.6. 搜索引擎的核心要素

1、索引速度

即每小时能够检索的文档数

2、搜索速度

延迟是索引大小的函数

3、查询语言的表达能力

即能够表达复杂的信息需求或加快复杂查询的速度

4、用户幸福感

1）数据检索（data retrieval）性能评估依据（确定正确性后）：

响应时间

索引空间

2）信息检索（information retrieval）绩效评估依据：

答案集的相关性

 

注意data retrieval和information retrieval的区别

## 6.7. 衡量关联性（relevance）的要素

1、基准文档集

2、一组基准查询

3、对每个查询文档对进行相关或不相关的二元评估

|               | Relevant | Irrelevant |
| ------------- | -------- | ---------- |
| Retrieved     | RR       | IR         |
| Not Retrieved | RN       | IN         |

Precision P = RR / (RR + IR)

Recall    R = RR / (RR + RN)

 

precision和recall一般成负相关

 



# 1. 最左堆（leftist heaps）

## 1.1. 基本概念

目标：在O(N)的时间复杂度内加速归并

NPL（null path length），Npl(X)指节点X到任意叶节点的最短路径

注意：Npl(NULL)=-1

Npl(X) = min { Npl(C) + 1 for all C as children of X }

 

最左堆属性是在堆中的每个节点X的左子树的Npl不小于右子树的Npl

定理：一个具有r个节点在右路径上的最左树一定有至少2r-1个节点（可用归纳法证明）

好处：我们能在右路径上进行所有的工作，从而使其时间复杂度降低

## 1.2. 归并操作递归版本

1、基本操作

Step 1：Merge( H1->Right, H2 )

Step 2：Attach( H2, H1->Right )

Step 3: Swap(H1->Right, H1->Left ) if necessary

 

2、伪代码：

```
PriorityQueue  Merge ( PriorityQueue H1, PriorityQueue H2 )

{ 

​	if ( H1 == NULL )  return H2;	

​	if ( H2 == NULL )  return H1;	

​	if ( H1->Element < H2->Element )  return Merge1( H1, H2 );

​	else return Merge1( H2, H1 );

}

static PriorityQueue

Merge1( PriorityQueue H1, PriorityQueue H2 )

{ 

​	if ( H1->Left == NULL ) 	/* single node */

​		H1->Left = H2;	/* H1->Right is already NULL 

​				  and H1->Npl is already 0 */

​	else {

​		H1->Right = Merge( H1->Right, H2 );   /* Step 1 & 2 */

​		if ( H1->Left->Npl < H1->Right->Npl )

​			SwapChildren( H1 );	/* Step 3 */

​		H1->Npl = H1->Right->Npl + 1;

	} /* end else */

	return H1;

}
```



## 1.3. 归并操作迭代版本

Step 1: Sort the right paths without changing their left children

Step 2: Swap children if necessary

## 1.4. 删除根节点

Step 1: Delete the root

Step 2: Merge the two subtrees

 

## 1.5. 时间复杂度

合并两个左堆的时间复杂度为O(logN)，因为这个相当于把右路径的长度相加

删除根节点的时间复杂度为O(log N)

注意：迭代版本和递归版本的归并操作时间复杂度均相同，迭代版本效率高一点

# 2. 斜堆（skew heaps）

## 2.1. 定义

斜堆是最左堆的一个简化版本，斜堆不需要存储Npl信息

斜堆始终交换左右子节点，除非右路径上最大的节点没有交换其子节点。

skew heaps的定义

1）只有一个元素的堆是斜堆

2）两个斜堆通过斜堆的合并操作，得到的结果仍是斜堆

## 2.2. 递归实现

1、如果一个空左倾堆和一个非空左倾堆合并，返回非空左倾堆

2、如果两个左倾堆都非空，那么比较两个根节点。取较小的节点为新的根节点（为了符合堆的优先级要求），合并较小根节点堆的右子堆和较大根节点堆。

3、交换右子堆和左子堆。

## 2.3. 迭代实现

1、分别把两个堆的右路径上所有节点的右子树分离出来。

2、把分离出来的子树按根节点元素升序（广义上的升序）排列。

3、把倒数第二个树左右子树交换，把最后一个树作为倒数第二个树的左子树，之后重复此操作依次向前直到最小根元素为止

## 2.4. 时间复杂度

merge操作的时间复杂度：摊还时间为O(logN)，最坏情况为O(N)

## 2.5. 注意点

1、倾斜堆的优点是无需额外的空间来保持路径长度，也无需测试来确定何时交换子级

2、精确确定左堆和斜堆的预期右路径长度是一个开放的问题。

3、如果将节点1到2k-1插入一个空的最小歪堆，则所得到的树始终是一个满二叉树

 

# 计算递归时间复杂度的方法

## 递归树

递归树本质就是将所有的递归情况转化成一棵树，针对该树的每一层计算所需的时间复杂度，最后将所有层的时间复杂度相加即可

> 注意：递归树所求的时间复杂度可以是一个范围，但是数量级要相同

