# python

## 环境搭建

### 解释器

- python解释器的种类
  - Cpython，C语言开发的解释器，是官方的解释器，应用广泛的解释器
  - IPython，基于CPython的一种交互式解释器
  - 其他解释器
    - PyPy，基于Python语言开发的解释器
    - Jython，运行在java平台的解释器，直接把Python代码编译成java字节码执行
    - IronPython，运行在微软.net平台上的python解释器，可以直接把python代码编译成.Net的字节码

### pycharm

- pycharm是python的编辑环境
- pycharm支持设置解释器，可以通过setting中的project进行设置

### 命令行运行py文件

在py文件的目录下打开命令行

使用命令 `python3 文件名.py` 运行py文件

## 注释

### 注释的作用

- 注释能够通过用自己熟悉的语言，在程序中对某些代码进行标注说明，这就是注释的作用，能够大大增强程序的可读性

### 注释的分类及语法

- 单行注释

只能注释一行内容，语法如下

```python
# 注释内容
```

- 多行注释

python中允许使用没有名字的三引号字符串作为多行注释来注释多行内容

多行注释一般用在注释一段代码的情况下，语法如下

```python
"""
	第一行注释
	第二行注释
	第三行注释
"""
'''
	第一行注释
	第二行注释
	第三行注释
'''
```

## 变量相关

### 定义变量

变量名 = 值

> 变量名自定义，要满足标识符命名规则
>
> python中允许随时定义变量，且定义变量时无需为变量设置类型

### 标识符

标识符命名规则时python中定义各种名字时候的统一规范，需要满足以下条件

- 由数字、字母、下划线组成
- 不能数字开头
- 不能使用内置关键字
- 严格区分大小写

### 命名习惯

- 见名知义
- 大驼峰：每个单词首字母都大写
- 小驼峰：第二个（含）以后的单词首字母大写
- 下划线命名法

### 使用变量

python中的变量类似于绑定的关系，变量数据发生变化，变量也会发生变化

python允许随时定义变量，且无需为变量设置类型，但是变量在使用前必须声明

## Debug工具

Debug是pycharm IDE中集成的用来调试程序的工具，在这里程序员可以查看程序的执行细节、流程或者调试bug

Debug工具使用步骤

1. 打断点
2. Dubug调试
   - 在debug面板中会直接显示当前所有变量

### 打断点

- 断点位置
  - 目标要调试的代码块的第一行代码即可，即第一个断电即可
- 打断点的方法
  - 在pycharm中单击目标代码的行号右侧空白位置

## 输出

### 格式化输出

#### 格式化符号

| 格式符号 |       转换符号       |
| :------: | :------------------: |
|    %s    |        字符串        |
|    %d    |  有符号的十进制整数  |
|    %f    |        浮点数        |
|    %c    |         字符         |
|    %u    |   无符号十进制整数   |
|    %o    |      八进制整数      |
|    %x    | 十六进制整数（大写） |
|    %X    | 十六进制整数（小写） |
|    %e    | 科学计数法（小写e）  |
|    %E    | 科学计数法（大写E）  |
|    %g    |     %f和%e的简写     |
|    %G    |     %f和%e的简写     |

> 技巧

- %06d，表示输出的整数显示位数，不足以0补全，超出当前位数则原样输出
- %.2f，表示小数点后显示的小数位数
- 如果需要原样输出，则可使用%s进行输出



格式化输出符号的使用方式（与C语言类似）：

```
print('%s %d' % (name,age))
```

#### f''格式化字符串

字符串输出除了使用%s外，还可以使用f''格式化字符串

语法：

```
f'{标识符}'
```

具体样例：

```python
print(f'我的名字是{name}，明年{age+1}岁了')
```

> f''格式化字符串是Python3.6中新增的格式化方法，该方法更简单易读

#### format方法格式化输出

python还支持format方法格式化输出，该方法与f''格式化字符串类似，但更灵活

具体样例：

```
# {1:{3}^10} 1表示位置，{3}表示用第3个参数来填充，^表示居中，10表示占10个位置
tplt = "{0:^10}\t{1:{3}^10}\t{2:^10}"   
print(tplt.format("排名","学校名称","总分",'*'))
```

### 转义字符

只需记住`\n`（换行符）和`\t`（制表符）具体查询转义字符表

### 结束符

在python中，print()函数默认自带`end="\n"`这个换行结束符，用户可以按需求更改结束符

例如：

```
print('输出的内容',end=",")
```

## 输入

### 语法

```python
input("提示信息")
```



### 输入的特点

- 当程序执行到`input`时，等待用户输入，输入完成之后才能继续向下执行
- 在python中，`input`接收用户输入后，一般存储到变量，方便使用
- 在python中，`input`会把接收到的任意用户输入的数据都当作字符串处理

### 转换数据类型的函数

|         函数         |                        说明                        |
| :------------------: | :------------------------------------------------: |
|    int(x[,base])     |   将x转换为一个整数，base为进制数，默认为十进制    |
|       float(x)       |                将x转换为一个浮点数                 |
| complex(real[,imag]) |       创建一个就复数，real为实部，imag为虚部       |
|        str(x)        |                将对象x转换为字符串                 |
|       repr(x)        |             将对象x转换为表达式字符串              |
|      eval(str)       | 用来计算字符串中的有效python表达式，并返回一个对象 |
|       tuple(s)       |               将序列s转换为一个元组                |
|       list(s)        |               将序列s转换为一个列表                |
|        chr(x)        |          将一个整数转换为一个Unicode字符           |
|        ord(x)        |          将一个字符转换为它的ASCII整数值           |
|        hex(x)        |         将一个整数转换为一个十六进制字符串         |

> 如果输入时没有定义输入的数据类型，则在转换数据类型之前需要用`type()`函数判断输入数据的类型

### 运算符的分类

- 算数运算符

| 运算符 |  描述  |
| :----: | :----: |
|   +    |   加   |
|   -    |   减   |
|   *    |   乘   |
|   /    |   除   |
|   //   |  整除  |
|   %    |  取余  |
|   **   |  指数  |
|  （）  | 小括号 |

> 运算符优先级：`()`高于`**`高于`*` `/` `//`高于`%`高于`+` `-`

- 赋值运算符

| 运算符 |    描述    |
| :----: | :--------: |
|   =    | 赋值运算符 |

​	单个变量赋值

```python
num = 1
```

​	多个变量赋值

```
num1, float1, str1 = 10, 0.5, 'hello'
```

​	注意：python允许多个变量赋相同值

```python
a = b = 1
```

- 复合赋值运算符

例如：`+=`

注意：python中先计算复合赋值运算符右侧表达式，再算左侧表达式

例如：

```
a = 10
a *= 1+3
# a的返回值为30
```

- 比较运算符

与C中运算符相同，比较完后返回值为bool类型（只有这种类型）

- 逻辑运算符

| 运算符 | 逻辑表达式 |       描述        |
| :----: | :--------: | :---------------: |
|  and   |  x and y   | 与；规则与C++相同 |
|   or   |   x or y   | 或；规则与C++相同 |
|  not   |   not x    | 非；规则与C++相同 |

> 注意：使用逻辑运算符的时候尽量使用()将表达式围起来，避免出现歧义

> 拓展：数字之间的逻辑运算
>
> ​			and运算符：只要两个数值中有一个为0，则结果为零，否则返回最后一个非零数字
>
> ​			or运算符：只有所有值为0结果才为0，否则返回第一个非0数字

# 流程控制

## 条件语句

### if语句和if...else...语句

语法：

```python
if 条件:
    条件成立执行的代码
    
if 条件:
    条件成立执行的代码
else:
    条件不成立时执行的代码
```

### 多重判断语句

```python
if 条件1:
    条件1成立执行的代码  
elif 条件2:
    条件2成立执行的代码
else:
    以上条件均不成立时执行的代码
```

### if嵌套

if嵌套指一个if语句中可以嵌套另外一个if，例如

```
if 条件1:
    条件1成立执行的代码  
	if 条件2:
    	条件2成立执行的代码

```

### 三目运算符

三目运算符也叫三元运算符或三元表达式

注意：读三元运算符的时候一定不要从左开始

语法如下：

```
条件成立执行的表达式 if 条件 else 条件不成立执行的表达式
```

## 循环

### while循环

语法

```python
while 条件:
    条件成立时重复执行的代码
```

### for循环

语法

```python
for 临时变量 in 序列 :
    重复执行的代码1
```

### 循环的else

#### while...else...

语法

```python
while 条件:
    条件成立重复执行的代码
else:
    循环正常结束后执行的代码
```

#### for...else...

语法

```python
for 临时变量 in 序列:
    重复执行的代码
else:
    循环正常结束后的代码
```

#### break和continue对else的影响

> else只在循环正常结束后才执行，
>
> 如果循环体中有continue，也属于正常结束的循环，仍然执行else中的语句
>
> break终止的循环属于非正常结束，else中语句不执行

### break和continue

break：在循环过程中用于终止循环

continue：在循环过程中用于退出当前循环继而执行下一次循环代码

### 循环嵌套

类似于if嵌套

# 数据类型

## 布尔型

布尔类型即bool类型，是用来表示真假的一种类型，其值仅有 `true` 和 `false` 两种类型

## 字符串

> 注意：python中的字符串是不可变类型，即不可直接修改内部元素的值，但可以直接重新赋值

### 字符串的表示

- 用一对引号表示字符串

在python中，使用 `''` 或 `""` 来表示字符串都是合法的

```python
name1 = 'Tom'
name2 = "Rose"
```

- 用三引号表示字符串

在python中，允许使用一对 `'''` 来表示字符串，同时使用这种方式允许进行回收按行

> 如果需要在字符串中使用引号，则需要使用不同的引号或使用转移字符 `\'` 或 `\"`

### 切片

> 切片是指对操作对象截取其中一部分的操作。字符串、列表、元组都支持切片

语法

```python
序列[开始下标位置:结束下标位置:步长]
```

> 注意：
>
> 1. 书写下标时，正负整数均可使用，负数表示从前往后数
> 2. 切片不包含结束位置下标所对应的位置
> 3. 如果需要剪切到结尾，可以采用序列[开始下标位置::步长]的写法
> 4. 步长时选取间隔，正负整数均可，默认步长为1

### 常用操作方法

|               方法名称               |                             作用                             |                           注意事项                           |
| :----------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| find(子串,开始位置下标,结束位置下标) | 检测某个字串是否包含在这个字符串中，如果包含则返回这个子串开始的位置下标，否则返回-1 | 该方法开始和结束位置下标可以省略，省略则表示在整个字符串中查找 |
|   replace(旧子串,新子串,替换次数)    |            用新子串替换旧子串，返回修改后的字符串            |                   该方法不会修改原有字符串                   |
|         split(分割字符,num)          |                    按照指定字符分割字符串                    |    num表示的是分割字符出现的次数，即返回数据个数为num+1个    |
| 字符或子串.join（多字符串组成的序列) | 用一个字符或子串合并字符串，即将多个字符串合并为一个新字符串 |                    需要注意join的使用方法                    |
|            strip([text])             | 删除字符两侧中与text子串相同的内容，参数text为子串，默认为空格 |               该函数直接作用于字符串，无返回值               |
|              isalpha()               | 如果字符串至少有一个字符并且所有字符都是字母则返回True，否则返回False |                                                              |
|              isdigit()               |        如果字符串只包含数字则返回True，否则返回False         |                                                              |
|              isspace()               |        如果字符串只包含空格则返回True，否则返回False         |                                                              |

### 其他操作方法

|                  方法名称                   |                             作用                             |                      注意事项                      |
| :-----------------------------------------: | :----------------------------------------------------------: | :------------------------------------------------: |
|                capitalize()                 |       将字符串第一个字符转换成大写，返回修改后的字符串       |  该函数转换后，只有第一个字符大写，其他字符都小写  |
|                   title()                   |     将字符串每个单词首字母转换成大写，返回修改后的字符串     |                                                    |
|                   upper()                   |      将字符串每个小写字母转换成大写，返回修改后的字符串      |                                                    |
|                   lower()                   |      将字符串每个大写字母转换成小写，返回修改后的字符串      |                                                    |
|               lstrip([text])                | 删除字符左侧中与text子串相同的内容，参数text为子串，默认为空格 |          该函数直接作用于字符串，无返回值          |
|               rstrip([text])                | 删除字符右侧中与text子串相同的内容，参数text为子串，默认为空格 |          该函数直接作用于字符串，无返回值          |
|            ljust(长度,填充字符)             | 返回一个字符串左对齐，并使用指定字符填充至对应长度的新字符串 |     该方法不修改字符串内容，而是直接返回新内容     |
|            rjust(长度,填充字符)             | 返回一个字符串左对齐，并使用指定字符填充至对应长度的新字符串 |     该方法不修改字符串内容，而是直接返回新内容     |
|            center(长度,填充字符)            | 返回一个字符串左对齐，并使用指定字符填充至对应长度的新字符串 |     该方法不修改字符串内容，而是直接返回新内容     |
| startwith(子串，开始位置下标，结束位置下标) | 判断字符串序列中从指定开始位置到指定结束位置的子串是否以所给的子串开头，是则返回true，反之返回false | 开始和结束的位置下标如果未给出则默认匹配整个字符串 |
|  endwith(子串，开始位置下标，结束位置下标)  | 判断字符串序列中从指定开始位置到指定结束位置的子串是否以所给的子串结尾，是则返回true，反之返回false | 开始和结束的位置下标如果未给出则默认匹配整个字符串 |

> 注意：以上方法如无特殊说明均以字符串.方法的形式进行调用

## 列表

### 下标

列表可以通过下标查找对应的元素

### 常用方法

|               方法名称                |                             作用                             |         注意事项         |
| :-----------------------------------: | :----------------------------------------------------------: | :----------------------: |
| index(数据,开始位置下标,结束位置下标) |                  返回指定数据所在位置的下标                  |                          |
|            cout(指定数据)             |              统计指定数据在当前列表中出现的次数              |                          |
|               len(序列)               |               访问列表长度，即列表中数据的个数               |  这是一个函数，不是方法  |
|             append(数据)              |                       列表结尾追加数据                       |                          |
|             extend(数据)              | 列表结尾追加数据，如果数据是一个序列，则将这个序列的数据逐一添加到列表 | 注意该方法与append的区别 |
|         insert(位置下标,数据)         |                       指定位置新增数据                       |                          |



### 判断数据在列表中是否存在

使用 `in` 和 `not in` 可以直接判断数据是否存在于列表中

### 删除列表中的数据

- del

语法：

```
del 目标
```

> 注意：del既可以删除整个列表（包括列表标识符），也可以删除指定数据



- pop()：删除指定下标的数据（默认为最后一个）并返回该数据

语法：

```
列表序列.pop(下标)
```



- remove()：移除列表中某个数据的第一个匹配项

语法：

```
列表序列.remove(数据)
```



- clear()：清空列表

语法

```
列表序列.clear()
```



### 修改列表中的数据

- 修改指定下标的数据

```
列表序列[下标] = 要修改的值
```



- 逆置序列reverse()

```
列表序列.reverse()
```



- 排序

```
列表序列.sort( key=None, reverse=False)
```

> 注意：reverse表示排序规则，reverse = True 降序， reverse = False 升序（默认）



### 复制列表中的数据

函数：列表序列.copy()

该函数返回原有列表序列的复制

> 注意：如果直接将一个列表序列赋给另外一个变量，则修改任意一个列表后，另外一个列表中的			数据也会被修改



### 列表的循环遍历

利用循环语句的规则即可



## 元组

元组中可以存储多个数据，元组内的数据是不能修改的。元组可以视为不能修改的列表

元组特点：定义元组使用小括号，且逗号隔开各个数据，数可以为不同的类型

### 定义元组

定义方式见下方三种

```
# 多个数据的元组
t1 = (10,20,30)

# 单个数据的元组，注意后面的逗号是必须的，否则会被定义为其他类型
t2 = (10,)

# 利用tuple()定义
t3 = tuple()
```

### 元组的常见操作

- 按下标查找数据

```
元组[下标]
```



- index()：查找某个数据，如果数据存在则返回对应的下标，否则报错，语法和列表、字符串的index方法相同

```
元组.index()
```



- count()：统计某个数据在当前元组出现的次数

```
元组.count(数据)
```



### 元组中的修改

> 注意：
>
> 1. 元组内的直接数据如果修改则立即报错
> 2. 但是元组里如果有列表，修改列表里面的数据则是支持的



## 集合

> 创建集合使用`{}`或`set()`，但是如果要创建空集合只能使用`set()`，因为 `{}` 被用来创建空字典

### 集合的常见操作

#### 添加数据

- add()

```
s1 = {10, 20}
s1.add(100)
s1.add(10)
# 返回结果为{100,10, 20}
```

> 因为集合有去重功能，如果向集合追加集合内已有数据的话则不会进行任何操作

- update()：追加的数据是序列

```
s1 = {10, 20}
# s1.update(100)	# 报错，因为100是int类型，不支持迭代
s1.update('abc')	# 可以正常运行，因为’abc‘是字符串，支持迭代
# 返回结果为{10, 20, 'a', 'b', 'c'}
```

#### 删除数据

- remove()，删除集合中的指定数据，如果数据不存在则报错
- discard()，删除集合中的指定数据，如果数据不存在也不会报错

#### 查找数据

- in：判断数据在集合内
- not in：判断数据不在集合内

## 字典

### 创建字典的语法

字典特点：

- 符号为大括号
- 数据为键值对形式出现
- 各个键值对之间使用逗号隔开

具体创建语法：

```
# 有数据字典
dict1 = {'name':'Tom', 'age':20, 'gender':'男'}
# 空字典
dict2 = {}
dict3 = dict()
```

> 注意：一般称冒号前面的为键（key），简称k；称冒号后面的为值（value），简称v

### 字典的常见操作

#### 新增数据

写法：字典序列[key] = 值

> 注意：
>
> - 如果key存在则修改这个key对应的值，如果key不存在则新增此键值对
> - 字典为可变类型

#### 删除数据

- del()/del：删除字典或删除字典中指定的键值对

```
dict1 = {'name':'Tom', 'age':20, 'gender':'男'}
# 删除字典中指定的键值对
del dict1['gender']
# 结果为{'name':'Tom', 'age':20}
```

> 注意：如果键值对不存在则会报错

- clear()：清空字典

```
字典.clear()
```

#### 修改数据

写法：字典序列[key] = 值

> 注意：如果key存在则修改这个key对应的值，但如果key不存在时则会新增键值对

#### 查找数据

- key值查找

具体语法略

> 注意：如果当前查找的key存在，则返回对应的值，否则将会报错

- get()

```
字典序列.get(key, 默认值)
```

> 注意：如果当前查找的key不存在则返回第二个参数（默认值），如果省略第二个参数，则返回None

### 字典的循环遍历

- 遍历字典的key

```
dict1 = {'name':'Tom', 'age':20, 'gender':'男'}
for key in dict1.keys():
	print(key)
```

- 遍历字典的value

```
dict1 = {'name':'Tom', 'age':20, 'gender':'男'}
for item in dict1.values():
	print(item)
```

- 遍历字典的元素

```
dict1 = {'name':'Tom', 'age':20, 'gender':'男'}
for item in dict1.items():
	print(item)
```

- 遍历字典的键值对

```
dict1 = {'name':'Tom', 'age':20, 'gender':'男'}
for key,value in dict1.items():
	print(f'{key} = {value}')
```

## 数据类型的公共操作

### 运算符

| 运算符 |      描述      |      支持的容器类型      |
| :----: | :------------: | :----------------------: |
|   +    |      合并      |       字符串、列表       |
|   *    |      赋值      |       字符串、列表       |
|   in   |  元素是否存在  | 字符串、列表、元组、字典 |
| not in | 元素是否不存在 | 字符串、列表、元组、字典 |

> 对于*运算符，使用方法如下
>
> ```
> str1 = 'a'
> str2 = str1*5
> # 返回结果为'aaaaa'
> ```

### 公共方法

|             函数             |                             描述                             |
| :--------------------------: | :----------------------------------------------------------: |
|            len()             |                      计算容器中元素个数                      |
|          del或del()          |                             删除                             |
|            max()             |                     返回容器中元素最大值                     |
|            min()             |                     返回容器中元素最小值                     |
|   range(start, end, step)    |      生成从start到end的数字，步长为step，供for循环使用       |
| enumerate(可遍历对象,start ) | 函数用于将一个可比案例的对象组合为一个索引序列，同时列出数据和数组下标，start默认是0 |

> enumerate()的使用方法
>
> ```
> list1 = ['a', 'b', 'c', 'd', 'e']
> for i in enumerate(list1):
> 	print(i)
> # 输出结果为abcde
> for index,char in enumerate(list1):
> 	print(f'下标是{index}，对应的字符是{char}')
> # 输出结果
> ```

### 推导式

> 推导式又叫生成式，可以用于列表，字典，集合的快速生成

> 推导式能够用于快速创建一个有规律的列表或控制一个有规律的列表

```
# 列表推导式
[xx for xx in range()]
# 字典推导式
{xx1:xx2 for ... in ...}
# 集合推导式
{xx for xx in ...}
```

# 函数

## 函数基础

### 定义函数

```
def 函数名(参数1,参数2 = 默认值, ...):
	代码1
	代码2
	...
	return 返回值
```

### 调用函数

```
函数名(参数1, 参数2, 参数3)
```

> 注意：
>
> 1. 参数是非必需的，参数的使用需要视情况而定
> 2. 在python中，函数必须先定义后使用
> 3. return会直接结束函数并返回相关的值

## 函数的说明文档

python提供了函数说明文档的功能，通过文档说明可以快速了解函数的作用

定义函数的说明文档：

```
def 函数名(参数):
	""" 
    函数作用
    :param a:参数1
    :param a:参数1
    ：return:返回值
    """
	代码
	.......
```

> 注意：只有在函数第一行使用多行注释的方式才是说明文档，其他位置并不能称为说明文档

查看函数的说明文档

```
help(函数名)
```

## 变量作用域

变量作用域指的是变量生效的范围，主要分为两类：局部变量和全局变量

- 局部变量

局部变量是定义在函数体内部的变量，即只在函数体内部生效

局部变量的作用：在函数体内部，临时保存数据，即当函数调用完后，则立即销毁局部变量

- 全局变量

全局变量是指在函数体内外都能生效的变量

> 注意：局部变量在函数体内部优先级比全局变量高，同名的情况下，优先修改局部变量

> 注意：全局变量无论在哪里被修改都是修改全局下的内容，除非函数体内部有另外一个同名的全局变量

## 函数返回值

在python中，函数的返回值既可以是一个参数，也可以是多个参数

多个参数的写法如下

```
# 下方两种方式均返回元组
return 1,2
return (1,2)
# 返回列表的写法
return [1,2]
# 返回字典的写法
return {'name':'Tom', 'age':30}
# 返回集合的写法
return (1,2)
```

## 函数参数的使用方法

### 位置传递参数

根据参数的类型按照顺序传递参数，与C类似，

详略

### 关键字传递参数

函数调用时，通过"键 = 值"形式加以指定。可以让函数更加清晰，也更容易使用，同时也清除了参数的顺序需求

> 注意：函数调用时，如果有位置参数，位置参数必须写在关键字参数的前面，但关键字参数之间不存在先后顺序

### 缺省参数（默认参数）

缺省参数用于定义函数，为参数提供默认值，调用函数时可不传该默认参数的值

> 注意：所有位置参数必须出现在默认参数前，无论是函数定义还是调用

### 不定长参数

不定长参数也叫可变参数。

不定长参数用于不确定调用时会传递多少个参数的场景。

不定长参数有两种写法：包裹位置传递和包裹关键字传递

> 注意：不定长参数允许不传参

- 包裹位置传递

```
def user_info(*args):
	print(args)
```

> 注意：传进的所有参数都会被args变量收集，它会根据传进参数的位置合并为一个元组，args是元组类型，这就是包裹位置传递

- 包裹关键字传递

```
def user_info(**kwargs):
	print(kwargs)
```

该方式可以理解为二维数组，传入的是键值对的形式

## 拆包和交换变量

### 拆包

拆包的本质就是用多个变量接收元组或者字典中每个单元的具体内容

注意：变量的个数需要和元组或者字典中单个单元的数组相同

- 元组拆包

元组拆包直接利用变量接收值即可

```python
a,b = (10,20)
print(a)
print(b)
# 输出值依次为10,20
```

- 字典拆包

对字典拆包所取出的是字典的key

```
dict1 = {'name':'Tom', 'age':20}
a,b = dict1
print(a,dict1(a))	# 打印内容为name Tom
print(b,dict1(b))	# 打印内容为age 20
```

### 交换变量

法1：借助第三方变量进行交换

法2：直接在同一个式子中交换值即可

```
a,b = 1,2
a,b = b,a
print(a)	# 2
print(b)	# 1
```



## lambda表达式

### lambda的应用场景

如果一个函数有一个返回值，并且只有一句代码，那么就可以使用lambda表达式进行简化

### lambda语法

```python
lambda表达式名称 = lambda 参数列表 : 表达式
```

> 注意：
>
> 1. lambda表达式的参数可有可无，函数的参数在lambda表达式中完全适用
> 2. lambda表达式能接收任何数量的参数但是只能返回一个表达式的值
> 3. 如果直接打印lambda表达式，输出的是此lambda表示式的内存地址

### lambda表达式的参数形式

#### 无参数

```
fn1 = lambda:100
print(fn1)	#100
```

#### 一个参数

```
fn1 = lambda a:a
print(fn1('hello world'))	#'hello world'
```

#### 默认参数

```
fn1 = lambda a,b,c=100:a+b+c
print(fn1(10,20))	#130
```

#### 可变参数

- 包裹位置传递

```
fn1 = lambda *args:args
print(fn1(10,20,30))	#(10,20,30)
```

- 包裹关键字传递

```
fn1 = lambda **kwargs:kwargs
print(fn1(name = 'python',age = 20))	#{'name': 'python', 'age': 20}
```

### lambda的应用

#### 带判断的lambda

```
fn1 = lambda a,b: a if a>b else b
print(fn1(10,20))	#20
```

#### 列表数据按字典的key值进行排序

```
student = [
	{'name': 'Tom', 'age': 20},
	{'name': 'Rose', 'age': 19},
	{'name': 'Jack', 'age': 22},
]

# 按name值升序排序
student.sort(key = lambda x: x['name'])

# 按name值降序排序
student.sort(key = lambda x: x['name'], reverse=True)

```

## 高阶函数

把函数作为参数传入，这样的函数称为高阶函数，高阶函数是函数式编程的体现。函数式编程就是值这种高度抽象的编程范式

函数式编程大量使用函数，减少了代码的重复，因此程序比较短，开发速度较快

高阶函数示例

```python
def sum_sum(a,b,f):
    return f(a) + f(b)

result = sum_sum(-1,2,abs)
print(result)
```

### 常用内置高阶函数

- map()

map(func, lst)	将传入的函数变量func作用到lst变量的每个元素中，并将结果组成新的列表(python2)/迭代器(python3)返回

> 注意：如果在python3中直接打印map返回的结果会输出<map object at 0xxxxxxxxxxxx>，如果要正常输出，需要用list对map返回的结果进行格式化

- reduce()

reduce(func, lst)	其中func函数必须有两个参数。每次func计算的结果继续和序列的下一个元素做累计计算

> 注意：reduce在functools模块中，使用前必须引入

样例：

```
import functools

list1 = [1,2,3,4,5]

def func(a,b):
	return a + b
result = functools.reduce(func,list1)

print(result)	# 15
```

- filter()

filter(func, lst)	该函数用来过滤序列，过滤掉不符合条件的元素，返回一个filter对象，如果要转化为列表，可以使用list()来转化

```python
list1 = [1,2,3,4,5]

def func(a,b):
	return a % 2 == 0
	
result = filter(func,list1)

print(result)	# <filter object at 0xxxxxxxxxx>
print(list(result))	# [2,4,6,8,10]
```



# 引用

## 什么是引用

在python中，值都是靠引用来传递的

> 引用即变量名仅作为一个标识名，存储的是地址而不是存储值

我们可以用 `id()` 来判断两个变量是否为同一个值的引用。

id值可以理解为变量所在内存的地址标识

## 可变类型和不可变类型

所谓可变类型与不可变类型是指：数据是否能够直接进行修改，如果能直接修改那么就是可变类型，如果不能则为不可变类型

- 可变类型 
  - 列表
  - 字典
  - 集合
- 不可变类型
  - 整型
  - 浮点型
  - 字符串
  - 元组

## 引用与函数实参

当变量作为函数实参时，分为如下两种情况

- 当变量为不可变类型时

不可变类型如int型等

函数形参指向的是实参所指向的值的地址，如果在函数中修改函数形参，修改的是函数形参所指向的地址，故而不会改变函数实参所指向的地址。

- 当变量为可变类型时

如果在函数中修改函数形参，修改的是原数据，并没有改变所指向的地址，因此形参修改后，实参中的值也会被修改

# 文件操作

文件操作步骤：

1. 打开文件
2. 读写等操作
3. 关闭文件

> 注意：可以只打开和关闭文件，不进行任何读写操作

## 打开和关闭

### 打开文件

在python，使用open函数打开一个已经存在的文件或者创建一个新文件，语法如下：

```python
文件对象 = open(path, mode[,encoding = '编码格式'])
或者
with open(path,mode[,encoding = '编码格式']) as 文件对象:
    文件对象.具体操作
```

> path：字符串，表示要打开的目标文件的路径
>
> mode：字符串，设置打开文件的模式（访问模式）：只读，写入，追加等

例如

```
f = open('test.txt', 'w')
```



- mode可选参数

| 模式 |                             描述                             |
| :--: | :----------------------------------------------------------: |
|  r   |                   以只读方式打开文件。默认                   |
|  rb  |                 以二进制格式只读方式打开文件                 |
|  r+  |                     打开一个文件用于读写                     |
| rb+  |              以二进制格式打开一一个文件用于读写              |
|  w   | 新建或打开一个文件用于写入（从头开始写入，原有内容会被删除） |
|  wb  | 以二进制格式新建或打开一个文件用于写入（从头开始写入，原有内容会被删除） |
|  w+  | 新建或打开一个文件用于读写（从头开始写入，原有内容会被删除） |
| wb+  | 以二进制格式新建或打开一个文件用于读写（从头开始写入，原有内容会被删除） |
|  a   |                  新建或打开一个文件用于追加                  |
|  a+  |        新建或打开一个文件用于读写，写入方式为追加模式        |
| ab+  |                 以二进制打开一个文件用于追加                 |

> 以上内容主要记住r、w、a即可，其他较少用
>
> r+、w+的区别：r+不会新建文件，如果文件不存在，则会直接报错，而w+会新建文件

### 关闭文件

利用close()可以关闭文件

例如：

```python
f.close()		# f为文件对象
```

## 读取和写入

- read()

```python
文件对象.read(num)
```

> num表示要从文件中读取的数据长度，如果没有传入num，那么就表示读取文件中所有的数据

- readlines()

readlines可以按照行的方式把整个文件中的内容进行一次性读取，并且返回的是一个列表，其中每一行的数据为 一个元素

- readlines()

readlines()一次只读取文件中一行内容，每次读取从上一次读取的下一行开始

## seek函数

- 作用

用来移动文件指针

- 语法

```python
文件对象.seek(偏移量, 起始位置)
```

> 偏移量为偏移的字符数
>
> 起始位置：
>
> - 0	表示文件开头
> - 1	表示当前位置
> - 2	表示文件结尾

## 文件和文件夹的操作

在python中文件和文件夹的操作要借助os模块里面的相关功能，所以在进行文件操作前需要导入os模块

具体示例：

```python
import os

# 文件/文件夹重命名
os.rename(目标文件/文件夹名,新文件/文件夹名)

# 删除文件
os.remove(目标文件名)

# 创建文件夹
os.mkdir(文件夹名字)

# 删除文件夹
os.rmdir(文件夹名字)

# 获取当前目录，如果没有用chdir改变当前所在目录的话则输出当前py文件所在的路径(不包含该文件)
os.getcwd()

# 改变当前目录至指定路径
os.chdir(目录)

#获取指定目录下的所有文件的文件名，返回一个列表
os.listdir(目录)
```



# 面向对象

面向对象就是将编程当成是一个事物，对外界来说，事物是直接直接使用的，不用管它内部的情况，而编程就是设置事物能够做什么事

## 类和对象

面向对象编程过程中，有两个重要组成部分：类和对象

类和对象的关系：用类去创建一个对象

### 类

类是对一系列具有相同特征的行为和食物的统称，是一个抽象的概念，不是真实存在的食物

- 定义类

```python
class 类名(object):
    def __init__(self):
        # 添加实例属性
    def 函数1(self):
        函数代码
    def 函数2(self):
        函数代码
	...
    def 函数3(self):
        函数代码
    
```

> 类名要满足标识符命名规则，同时遵循大驼峰命名法

- self

self指的是调用该函数的对象，并不是这个类

在类中的所有方法中的第一个参数一定是self，该参数并不会接收用户传入的实参，接收用户实参的第一个参数为self参数后的第一个参数，例如：

```python
class Num(object):
    def add(self,a,b):
        return a + b	# a = 1,b = 2

t = Num()
print(t.add(1, 2))	# 3
```

### 对象

- 创建对象

```
对象名 = 类名()
```

> 一个类可以创建多个对象

- 类外面添加对象属性

```
对象名.属性名 = 值
```

- 类外面获取对象属性

```
print(对象名.属性名)
```

- 类里面获取对象属性

在类的方法中可以通过如下方法获取对象属性，该属性一般事先已经定义好了

```
self.属性名
```

### 魔法方法

在python中，形如 `__xx__()` 的函数叫做魔法方法，指的是具有特殊功能的函数

- `__init__(self)`

该方法可以用于初始化对象，即在对象第一次构建时会自动调用该方法为对象进行初始化

语法：

```python
# 不带参数的__init__(self)
class 类名():
	def __init__(self):
        # 添加实例属性
        self.height = 200
        self.width = 100

# 带参数的__init__(self)
class 类名():
	def __init__(self, height = 200, width = 100):
        # 添加实例属性
        self.height = height
        self.width = width
# 带参数__init__(self)的使用
对象名 = 类名(400, 200)
```



- `__str__(self)`

当使用print对象的时候，默认打印对象的内存地址。但如果类定义了`__str__` 方法，那么就会打印这个方法return的数据

> 该方法一般用于保存对象的大英信息

例如

```
class 类名():
	def __str__(self):
        return '这是一个说明文字'
```



- `__del__(self)`

当删除对象时，python解释器会默认调用该方法

### 类属性和实例属性

- 类属性就是类对象所拥有的属性，它被该类的所有实例对象所共有
- 类属性可以使用类对象或实例对象访问
- 类属性只能通过类对象修改，不能通过实例对象修改
- 原本的实例属性与类属性共用同一个地址，如果通过实例对象修改类属性，那么会创建了一个实例属性并修改而非修改了原有类属性，从而使得实例属性与类属性不再关联，从而造成错误，因此尽量不要直接修改实例属性

```python
class Dog(object):
    tooth = 10

wangcai = Dog()
xiaohei = Dog()

print(Dog.tooth)		# 10
print(wangcai.tooth)	# 10
print(xiaohei.tooth)	# 10
```

> 注意：在单独修改某个对象的tooth前，如果修改Dog.tooth，则所有该类的对象.tooth都会被修改，但如果某对象的tooth已经被修改过了，则该对象新建了一个实例属性，那么即使修改Dog.tooth也不会对其产生作用
>
> 如果只是修改某个对象.tooth，类和其余对象的tooth都不会被改变

### 类方法和静态方法

- 类方法特点

类方法需要用装饰器@classmethod来标识其为类方法，对于类方法，第一个参数必须是类对象，一般以cls作为第一个参数

- 类方法的使用场景

类方法和类属性一般配合使用，当方法中需要使用类对象（如访问是由类属性等）时，就需要定义类方法

- 类方法实例

```python
class Dog(object):
    __tooth = 10
    @classmethod
    def get_tooth(cls):
        return cls.__tooth
```

- 静态方法特点

需要通过装饰器@staticmethod来壮士，静态方法既不需要传递类对象也不需要传递实例对象（形参没有self/cls）

- 静态方法使用场景

当方法中既不需要使用实例对象（如实例对象，实例属性），也不需要使用类对象（类属性，类方法，创建实例等）时，定义静态方法

取消不需要的参数传递，有利于减少不必要的内存占用和性能消耗

- 静态方法的定义

```python
class Dog(object):
    @staticmethod
    def info_print():
        print('这是一个静态方法')

# 静态方法既可以使用对象访问又可以使用类访问
wangcai = Dog()
wangcai.info_print()
Dog.info_print()
```



## 面向对象三大特性之封装

将属性和方法书写到类的里面的操作即为封装

封装可以为属性和方法添加私有权限

### 私有权限

为属性和方法添加私有权限属于封装性

- 定义私有属性和方法

在python中，可以为实例属性和方法设置私有权限，即设置某个实例属性或实例方法不继承给子类（因为私有权限属性只有类内部才能访问，子类内部不是父类内部）

> 注意：私有属性和私有方法只能在类中进行访问和修改，在类外面无法进行

设置私有权限的方法：在属性名和方法名前面加上两个下划线

```python
class 父类():
    def __init__(self):
        self.__money = 200000
    def __self_method(self):
        print('这是一个私有方法')
```

- 获取和修改私有属性值

在python中，一般定义类中方法名get_xx用来获取私有属性，定义set_xx用来修改私有属性值

```python
class 父类():
	def get_money(self):
        return self.__money
    def set_money(self):
        self.__money = 500
    def __init__(self):
        self.__money = 200000
    def __self_method(self):
        print('这是一个私有方法')
```

## 面向对象三大特性之继承

继承是指：

- 子类默认继承父类的所有属性和方法（私有属性除外）

- 子类可以重写父类的属性和方法

### 拓展知识

python2中类是按照经典类处理的，而python3是按照新式类进行处理的

> 经典类：不由任意内置类型派生出的类
>
> 新式类：所有类都是在object这个顶级对象下派生出来的

### 继承介绍及其写法

- 介绍

python面向对象的继承指的是多个类之间的所属关系，即子类默认继承父类的所有属性和方法，例如

```python
# 父类A
class A(object):
	def __init__(self):
        self.num = 1
    def info_print(self):
        print(self.num)
        
# 子类B，继承A类
class B(A):
    pass	# pass是空语句，不做任何事情，一般用作占位语句

result = B()
result.info_print()		# 1
```

> 在python中，所有类默认继承object类，object类是顶级类（也叫基类）；其他子类叫做派生类

- 单继承

子类只继承一个父类，写法如上

- 多继承

子类同时继承多个类的属性和方法，写法如下：

```python
class A(object):
    pass
class B(object):
    pass
class C(A,B):
    pass
```

> 注意：当一个类有多个父亲的时候，默认使用第一个父类的同名属性和方法

- 子类重写父类同名方法和属性

子类中自己的方法优先级是最高的，如无特殊说明，优先调用子类的同名方法

同名方法的优先级：子类>第一个父类>第二个父类...>最后一个父类>object基类

- 快速查看类的继承关系

使用方法 `__mro__` 可以快速查看当前子类的继承关系

该方法按照顺序返回类的继承关系

```mysql
子类对象.__mro__()
```

- 子类如何调用父类的同名方法和属性

```python
法1：
# 调用父类方法，一般会在类中直接声明这样的方法，为了保证调用到的也是父类的属性，要在调用方法前调用父类的初始化方法
class child(father):
    def __init__(self):
        self.name = '子类'
    def print(self):
        print(self.name)
    def print_father(self):
        father.__init__(self)
        father.print(self)
# 法2(利用super()方法)：
# 方法2.1 
super(当前类名, self).__init__()
super(当前类名, self).函数()	# 该写法调用的是当前类名的父类的函数

# 方法2.2(无参数super)
super().__init__()
super().函数()	# 该写法调用的也是当前类名的父类的函数
```

> 注意：
>
> 在法1中：
>
> 如果要调用父类的同名方法，则一定要把self传递进去，然后父类的同名方法会对子类的self中的属性进行操作/更改
>
> 例如：如果调用了print_father方法后打印出了'父类'，如果此时直接调用子类的print方法，则打印出的也会是'父类'而不是'子类'
>
> 在法2中：
>
> 使用super可以自动查找父类，遵循`__mro__()` 的规则

- 多层继承

多层继承指继承关系大于两层的继承

## 面向对象三大特性之多态

多态指的是一类事物有多种形态（一个抽象类有多个子类，因而多态的概念依赖于继承）

> 注意：python中的多态不是必须依赖于继承

- 多态的定义

多态是一种使用对象的方式，子类重写父类方法，调用不同子类对象的相同父类方法可以产生不同的执行结果

> 简单来说就是传入不同的对象，产生不同的结果

- 多态的好处

调用灵活，有了多态，就能更容易地编写出通用的代码，做出通用的编程，以适应需求的变化

- 多态的实现步骤

1. 定义父类，并提供公共方法
2. 定义子类，并重写父类方法
3. 传递子类对象给调用者，可以看到不同子类执行效果不同

# 模块、包、异常

## 模块

python模块(Module)，是一个python文件，以.py结尾，包含了python对象定义和python语句

模块能定义函数，类和变量，模块里也能包含可执行的代码

### 导入模块的方式

- import 模块名
- from 模块名 import 功能名
- from 模块名 import *
- import 模块名 as 别名
- from 模块名 import 功能名 as 别名

写法1

```python
# 导入模块
import 模块名1，模块名2...

# 调用功能
模块名.功能名()
```

写法2

```python
from 模块名 import 功能1,功能2...

# 调用功能
功能名()
```

写法3

```
from 模块名 import *	# 导入内部所有代码，避免使用功能时需要写模块名的麻烦

# 调用功能
功能名()
```

### 制作模块

在python中，每个python文件都可以作为一个模块，模块的名字就是文件的名字。也就是说自定义模块必须要符合标识符命名规则

> 模块主要是为了实现复用性

- 定义模块

新建一个python文件，将其命名为 my_module1.py ，并定义testA函数

```
def testA(a, b):
	print(a + b)
```

- 测试模块

在实际开发中，当一个开发人员编写完一个模块后，为了让模块能够在项目中达到想要的效果，这个开发人员会自行在py文件中添加一些测试信息，例如在my_module1.py文件中添加测试代码：

```
def testA(a, b):
	print(a + b)

# 以下写法保证只在当前文件中调用该函数，在其他导入该文件的文件内不符合该条件，因此不执行testA函数调用
if __name__ = '__main__':
	testA(1,1)
```

> `__name__` 是一个系统变量，如果是在自身模块中使用，则其值为`'__main__'` ，如果不再自身模块调用，这其值为其所在的python文件名

- 导入模块

```python
import my_module1
```

### 模块定位顺序

当导入一个模块，Python解释器对模块位置的搜索顺序是：

1. 当前目录
2. 如果不在当前目录，Python则会搜索在shell变量PYTHONPATH下的每个目录
3. 如果都找不到，Python会察看默认路径，UNIX下，默认路径一般为/usr/local/lib/python/

模块搜索路径存储在system模块的sys.path变量中。变量里包含当前目录，PYTHONPATH和由解释器安装过程决定的默认目录

- 注意
  - 自己的文件名不要和已有模块名重复，否则将导致模块功能无法使用
  - 使用from 模块名 import功能时，如果功能名字重复，调用到的是最后定义或导入的功能

> 如果使用import模块名的方式导入，则不需要担心功能名字重复的问题，因为模块名一定不能相同

### `__all__`

如果一个模块文件中有`__all__` 变量，当使用 `from xxx import *` 导入时，只能导入这个列表中的元素

```python
# 模块文件my_module1.py
__all__ = ['testA']

def testA():
	print('testA')

def testB():
	print('testB')
    
    
# 使用模块
from my_module1 import *
testA()		# 能够成功被调用
testB()		# 不能够被调用，会报错，标识该函数未定义
```

## 包

包将有联系的模块组织在一起，即放到同一个文件夹下，并且在这个文件夹创建一个名字为 `__init__.py` 的文件，那么这个文件夹就称为包

- 制作包

在pycharm左边目录树下右键选择[New] — [Python Package] — 输入包名 — [OK] — 新建功能模块（有联系的模块）

> 注意：新建包后，包内部会自动创建`__init__.py` 文件，这个文件控制着包的导入行为

- 导入包

法1：

```
import 包名.模块名	# 导入包

包名.模块名.目标	# 调用功能
```

法2：

> 注意：法2必须在`__init__.py` 文件中添加 `__all__ = []` ，控制允许导入的模块列表（存储的是模块名，不带.py）

```python
from 包名 import *	# 导入包中所有模块
模块名.目标
```



## 异常

异常可以理解为bug

- 异常的写法

```python
try
	可能发生错误的代码
except [异常类型]	# 如果不写异常类型则表示发生任何异常均执行
	如果出现异常则执行的代码
```

> 1. 如果尝试执行的代码的异常类型和要捕获的异常类型不一致，则无法捕获异常
> 2. 一般try下方只放一行尝试执行的代码

- 异常类型

|       异常        |             描述             |
| :---------------: | :--------------------------: |
|     NameError     | 未声明/初始化对象 (没有属性) |
| ZeroDivisionError |         除(或取模)零         |
|  AttributeError   |       对象没有这个属性       |

- 捕获多个指定异常

当捕获多个异常时，可以把要捕获的异常类型的名字放到except后，并用元组的方式进行书写

例如：

```python
try:
    print(1/0)
except (NameError, ZeroDivisionError):
    print('有错误')
```

- 捕获异常描述信息

```python
try:
    print(num)
except (NameError, ZeroDivisionError) as result:	# result存储着捕获的异常描述信息
    print(result)
```

> 捕获异常描述信息指输出异常的具体描述内容而非异常类型

- 捕获所有异常

Exception是所有程序异常类的父类，可以利用该异常类型捕获所有异常类型

```python
try:
    print(num)
except Exception as result:
    print(result)
```

- 异常的else

else表示的是如果没有异常要执行的代码

```python
try:
    print(1)
except Exception as result:
    print(result)
else:
	print('我是else，是没有异常的时候执行的代码')
```

- 异常的finally

finally表示的是无论是否异常都要执行的代码，例如关闭文件

```python
try:
    f = open('test','r')
except Exception as result:	
    f = open('test','w')
else:
	print('没有异常')
finally:
	f.close
```

- 异常的传递

异常传递指的是try中嵌套了多个try，异常处理由外层传递到了内层

- 自定义异常

在python中，抛出自定义异常的语法为 `raise 异常类对象` 

例如下方定义了一个用户输入密码长度不足3位则报错的异常：

```python
# 自定义异常类，继承Exception
class ShortInputError(Exception):
	def __init__(self,length, min_len):
        self.length = length
        self.min_len = min_len
    # 设置抛出异常的描述信息
    def __str__(self):
        return f'你输入的长度是{self,length}，不能少于{self.min_len}个字符’
    
def main():
    try:
        con = input('请输入密码：')
        if len(con) < 3:
            raise ShortInputError(len(con),3)
    exception Exception as result:
        print(result)
    else:
        print('密码已经输入完成')
        
main()
```

