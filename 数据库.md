transaction	交易

duplication	重复

redundancy	冗余

integrity		完整性

consistency	一致性

atomicity	原子

concurrent	并发

semantic	语义

instance		实例

schema		模式

scenario		场景、设想

explicitly	显式地

performance	性能

enterprise	企业

architecture	体系结构、架构

semistructured	半结构化的

analogous	类似于

interfaces	接口

beneath		在……下

compiler	编译

Domain of Attribute	属性域

complications	难题

complications	使变得更复杂的问题

snapshot	快照

Database-management system 

(DBMS) 

Database-system applications 

Online transaction processing 

Data analytics 

File-processing systems 

Data inconsistency 

Consistency constraints 

Data abstraction 

Physical level 

Logical level 

View level 

Instance 

Schema 

Physical schema 

Logical schema 

Subschema 

Physical data independence 

Data models 

Entity-relationship model 

Relational data model 

Semi-structured data model 

Object-based data model

# 第一章introduction

 

## 1.1. 数据库系统（Database system）

### 1.1.1. 什么是数据库系统

数据库系统被设计用来存储大量的信息。

数据的管理包括定义存储信息的结构，以及提供操纵信息的机制。

数据库系统必须提供在面对系统崩溃或尝试未经授权的访问时存储的信息的安全。

如果要在多个用户之间共享数据，则系统必须避免可能出现的异常结果。

数据库系统是相关数据和一组程序的集合，允许用户访问和修改这些数据。

 

数据库系统的主要目的之一是为用户提供数据的抽象视图。也就是说，系统隐藏了数据如何存储和维护的某些细节。

 

数据库系统今天无处不在，大多数人每天都直接或间接地与数据库交互。

 

### 1.1.2. 数据库管理系统（Database Management System，DBMS）

数据库管理系统(DBMS)由相关数据的集合和访问这些数据的程序集合组成。这些数	据描述了一个特定的企业。

DBMS的主要目标是提供一种既方便又高效的存储和检索数据库信息的方法。

 

### 1.1.3. 数据库应用系统（Database application）

数据库应用系统是在数据库管理系统（DBMS）支持下建立的一种计算机应用系统。

 

### 1.1.4. 数据库

数据的集合，通常称为数据库，包含与企业相关的信息。

 

### 1.1.5. 数据库需要解决的问题

将数据存储到哪里

怎样去组织数据

怎样去访问（access）数据

怎样去高效地访问数据

怎样确保数据安全

怎样确保数据的一致性（consistency）

怎样处理并发数（concurrent access）

 

### 1.1.6. 数据库系统用于管理以下数据的集合

高价值的数据、相对较大的数据和可以被多个用户和应用程序同时访问的数据

### 1.1.7. 数据库的使用模式（广义上说）

第一种模式是支持在线事务处理，其中大量用户使用数据库，每个用户检索相对较少的数据，并执行较小的更新。这是绝大多数数据库应用程序用户的主要使用模式

第二种模式是支持数据分析，即处理数据以得出结论，并推断规则或决策过程，然后用来驱动业务决策。

 

## 1.2. 数据库系统的目的

### 1.2.1. 使用文件系统（file systems）存储数据的缺点

1、数据冗余且不一致（Data redundancy and inconsistency）

会存在多种文件形式，在不同文件中存在重复的（redundancy）信息

2、访问数据困难（Difficulty in accessing data）

传统的文件处理环境不允许以方便和有效的方式检索所需的数据。一般使用需要更	灵敏的数据检索系统。

3、数据隔离（Data isolation）

由于数据分散在不同的文件中，并且文件可能是不同的格式，因此编写新的应用程	序来检索适当的数据是困难的。

4、完整性问题（Integrity problems）

完整性是指数据在其生命周期中的准确性和一致性

很难去添加新的约束或改变现存的约束条件

4、更新异常（atomicity updates）或者原子问题（Atomicity problems）

在传统的文件处理系统中，很难保证原子性。

5、多个用户的并发访问（Concurrent-access anomalies）

​	并发访问需要性能（performance）

没有被控制的并发访问可能导致不连续性的产生

6、安全问题（Security problems）

并非数据库系统的每个用户都应该能够访问所有的数据

 

## 1.3. 数据视图

### 1.3.1. 数据模型（data models）

1、什么是数据模型

数据模型是数据库结构的基础，是用于描述数据、数据关系、数据语义和一致性约束的概念性工具的集合。

数据模型的重要特性之一是它们对数据库用户甚至数据库应用程序开发者都隐藏了	这些低级的实现细节。数据库系统允许应用程序开发人员使用数据模型的抽象来存储和	检索数据，并将抽象操作转换为在底层实现上的操作。

2、数据模型的分类

1）关系模型（Relational Model）

关系数据模型是使用最广泛的数据模型，是大多数数据库应用程序的基础。

在关系模型中，数据以表的形式表示。每个表都有多个列，并且每个列都有一个		唯一的名称。表中的每一行都代表一条信息。

 

2）实例关联模型（Entity-Relationship Model）

实例关联模型使用一组称为实例的基本对象并运用这些对象之间的关联

实例关联模型在数据库设计中得到了广泛的应用

 

3）半结构化数据模型（Semi-structured Data Model）

半结构化数据模型允许指定数据，其中相同类型的各个数据项可能具有不同的属		性集。这与前面提到的数据模型相反（在前面的数据模型中，特定类型的每个数据项		都必须具有相同的属性集。）

JSON和可扩展标记语言(XML)是一种被广泛使用的半结构化数据表示方法。

 

4）基于对象的数据模型（Object-Based Data Model）

该类模型使得数据库系统允许将过程存储在数据库系统中，并由数据库系统执行。		这可以看作是用封装、方法和对象标识的概念来扩展关系模型。

 

### 1.3.2. 数据抽象化（Data Abstraction）

1、数据库系统必须有效地检索数据。对效率的需求导致数据库系统开发人员使用复杂的数据结构来表示数据库中的数据。

2、开发人员通过几个层次的数据抽象来向用户隐藏复杂性，以简化用户与系统的交互。

3、数据抽象的层次：

1）物理层次（physical level）

物理层次是最低级别的抽象，它描述了数据是如何实际存储的。

物理级别详细地描述了复杂的底层数据结构。

2）逻辑层次（Logical level）

逻辑层次高于物理层次，它描述了描述了哪些数据存储在数据库中，以及这些数		据之间存在哪些关系。

逻辑级别上实现简单结构可能涉及复杂的物理级结构，但逻辑级别的用户不需要		意识到这种复杂性（由于物理数据独立性）

3）视图层次（View level）

视图层次是最高级别的抽象，它只描述了整个数据库的一部分。

数据库系统的许多用户只需要访问数据库的一部分，因此视图层次简化了他们与		系统的交互应用程序能隐藏数据类型的细节。

 

### 1.3.3. 实例和模式（instances and Schemas）

1、实例和模式类似于编程语言中的类型和变量

2、模式是数据库的逻辑结构或者说总体设计，类似于（analogous）程序中变量的变量声明以及相关的类型定义

3、实例是在特定时刻存储在数据库中的信息的集合，类似于程序中的变量在某个时间点上的值

4、数据库的模式

数据库系统有几个模式，它们根据抽象的级别进行划分。

1）物理模式

物理模式在物理级别描述数据库设计

物理模式隐藏在逻辑模式之下，通常可以很容易地进行更改，而不影响应用程序

2）逻辑模式

逻辑模式在逻辑级别描述数据库设计。

逻辑模式对应用程序的影响是最重要的，应用程序取决于逻辑模式（Applications 	depend on the logical schema），程序员通过使用逻辑模式来构建应用程序。

 

3）视图模式

数据库在视图级别也可能有几个模式，有时称为子模式，它们描述数据库的不同视图。

 

4、物理数据独立性（Physical Data Independence）

是一种能够修改物理模式而不更改逻辑模式的能力（the ability to modify the physical 	schema without changing the logical schema）

物理数据独立性使得数据库系统在物理模式发生更改时，不需要重写应用程序。即	在某些部分发生更改时不会严重影响其他部分

一般来说，应该明确定义不同级别和组件之间的接口，以便某些部分的更改不会严重影响其他部分。（In general, the interfaces between the various levels and components should be well defined so that changes in some parts do not seriously influence others.）

## 1.4. 数据库语言

### 1.4.1. 数据定义语言（Data-Definition Language，DDL）

数据定义语言(DDL)是一种用于指定数据库模式和数据的其他属性的语言。

DDL编译器生成一组存储在数据字典中的表模板，数据字典包含元数据（metadata）

元数据包括：数据模式（Database schema）、完整性约束（integrity constraints）、权限（authorization）

### 1.4.2. 数据操作语言（Data-Manipulation Language）

同义词为查询语言（query language）

数据操作语言(DML)是一种允许用户访问或操作按适当的数据模型组织的数据的语言。

 

数据操作访问的类型：

1）检索（Retrieval of）存储在数据库中的信息。

2）将新的信息插入到数据库中。

3）从数据库中删除信息。

4）修改存储在数据库中的信息。

 

数据操作语言的类型：

1）过程性数据操作语言（Procedural DMLs）

要求用户指定需要哪些数据以及如何获取这些数据。

2）声明式数据操作语言（Declarative DMLs）（也称为nonProcedural DMLs）

要求用户指定需要哪些数据，而不指定如何获取这些数据。

数据库需要自己找到访问数据的有效方法

 

## 1.5. 数据库设计（Database Design）

数据库的设计主要涉及到数据库模式的设计。

实例关系(E-R)数据模型是一种广泛应用于数据库设计的模型。它提供了一种方便的图形表示方式来查看数据、关系和约束。

高级数据模型为数据库设计者提供了一个概念框架，在该框架中指定数据库用户的数据需求以及如何构建数据库以满足这些需求。

数据库设计的初始阶段是充分描述潜在数据库用户的数据需求。数据库设计者需要与域专家和用户进行广泛的交互来执行此任务。这个阶段的结果是对用户需求的规范。

 

## 1.6. 数据库引擎（Database Engine）

一个数据库系统被划分为多个模块，用来处理整个系统的每个职责。

数据库系统的功能组件可以大致分为

 

一个数据库系统大致可以分为存储管理器、查询处理器组件和事务管理组件三个子系统（subsystems）。

### 1.6.1. 存储管理器（storage manager）

1、存储管理器是数据库系统的组件，它提供了存储在数据库中的低级数据与提交给系统的应用程序和查询之间的接口

2、存储管理器负责与文件管理器的交互。

3、存储管理器将各种DML语句转换为低级的文件系统命令。

4、存储管理器负责在数据库中存储、检索和更新数据。

5、存储管理器组件包括：

1）授权和完整性管理器（Authorization and integrity manager）

2）事务管理器（Transaction manager）

3）文件管理器（File manager）

4）缓冲区管理程序（Buffffer manager）

6、存储管理器实现了几个作为物理系统实现的一部分的数据结构：

1）数据文件（data files）

它存储了数据库本身。

2）数据字典（data dictionary）

它存储关于数据库结构的元数据，特别是数据库的模式。

3）索引（indices）

它可以提供对数据项的快速访问

 

### 1.6.2. 查询处理器（The Query Processor）

查询处理组件包括：

1）DDL解释器（DDL interpreter）

它解释DDL语句并将定义记录在数据字典中

2）DDL编译器（DML compiler）

它将查询语言中的DML语句转换为一个由查询-评估引擎所理解的低级指令组		成的评估计划。一个查询通常可以转换为许多备选评估方案中的任何一种，这些方案		都能给出相同的结果。

DML编译器还执行查询优化；也就是说，它从这些备选方案中选择成本最低的		评估计划

3）查询运行引擎（Query evaluation engine）

它执行由DML编译器生成的低级指令。

会编译和执行DDL和DML语句，同时可以帮助数据库系统简化和方便对数据的访问。

### 1.6.3. 事务管理器（Transaction Management）

1、事务管理器由并发控制管理器和恢复管理器组成

2、并发控制管理器有责任控制并发事务之间的交互，以确保数据库的一致性。

3、事务是在数据库应用程序中执行单个逻辑功能的操作的集合。每个事务都是一个原子性和一致性的单位。

4、我们要求事务不违反任何数据库一致性约束。也就是说，如果在事务启动时数据库是一致的，那么在事务成功终止时数据库必须是一致的。

5、程序员有责任正确地定义各种事务，以便每个事务都保持数据库的一致性。

6、事务管理器允许应用程序开发人员将一系列数据库访问序列视为单个单元，要么完全发生，要么根本不发生，确保尽管出现系统故障，数据库仍保持一致（正确的）状态，也确保并发事务执行没有冲突。

7、在故障发生时，事务管理器必须执行故障恢复，即事务管理器必须检测系统故障，并将数据库恢复到在故障发生之前就已存在的状态。

 

## 1.7. 数据库和应用程序架构（Database and Application Architecture）

数据库系统的体系结构很大程度上受到数据库系统运行的底层计算机系统的影响。数据库系统可以是集中式的，也可以是并行的，涉及多台机器。

分布式数据库允许跨多个地理位置分离的机器进行数据存储和查询处理。

 

数据库应用程序通常被分为在客户端机器上运行的前端部分和在后端上运行的部分。在双层架构中，前端直接与运行在后端的数据库进行通信。在三层架构中，后端部分本身被分解为一个应用程序服务器和一个数据库服务器。

 

## 1.8. 数据库用户和管理员（Database Users and Administrators）

### 1.8.1. 数据库用户和用户界面（Database Users and User Interfaces）

有四种不同类型的数据库系统用户，区别他们期望与系统交互的方式。为不同类型的用户设计了不同类型的用户界面。

 

Naive users：

Naive user是一些不成熟的用户，他们通过使用预先定义的用户界面与系统进行交互，如web或移动应用程序。Naive user的典型用户界面是表单界面，用户可以在其中填写表单的适当字段。Naive user还可以查看从数据库中生成的阅读报告。

Application programmers：

Application programmers是编写应用程序的计算机专业人员。Application programmers

可以从许多工具中进行选择来开发用户界面。

Sophisticated users：

与系统进行交互，而无需编写程序。相反，他们可以使用数据库查询语言或使用数	据分析软件等工具来形成请求。

Database Administrator：

对数据和访问这些数据的程序都进行中央控制的人被称为数据库管理员(DBA)。

DBA的功能包括

1）Schema defifinition（架构定义）

DBA通过在DDL中执行一组数据定义语句来创建原始的数据库模式。

2）Storage structure and access-method defifinition(存储器的结构和访问方法定义)

DBA可以指定一些与数据的物理组织和要创建的索引有关的参数。

3）Schema and physical-organization modifification（模式和物理组织的修改）

DBA会对模式和物理组织进行更改，以反映组织不断变化的需求，或者更改			物理组织以提高性能。

4）Granting of authorization for data access（授予对数据访问的授权）

通过授予不同类型的授权，数据库管理员可以规范不同用户可以访问的数据			库的哪些部分。

授权信息保存在一个特殊的系统结构中，每当用户试图访问系统中的数据时，			数据库系统就会查阅该特殊的系统结构。

5）Routine maintenance（日常维护）

定期将数据库备份到远程服务器上，以防止在发生洪水等灾难时的数据丢失。

确保有足够的空闲磁盘空间可用于正常操作，并根据需要升级磁盘空间。

监视在数据库上运行的作业，并确保性能不会因某些用户提交的非常昂贵的			任务而降低。

 

## 1.9. 数据库系统的历史（History of Database Systems）

数据分析技术试图从数据中自动发现规则和模式。数据挖掘领域将人工智能研究人员和统计分析人员发明的知识发现技术与高效的实现技术相结合，使它们能够用于超大的数据库。

 

 

# 2. 关系模型

## 2.1. 关系数据库的结构

### 2.1.1. 名词解释

relation可以理解为一个集合，集合中的每个成员之间都符合集合之间的关系

关系数据库由表（table）的集合构成，每张表被赋予一个唯一的名称，表中的一行表示了一组值之间的某种联系。一个具有n个值的行可以称作一个n元组

在关系模型中，

关系（relation）指代 表（table）

元组（tuple）指代 行

属性（attribute）指代 列

关系实例（relation instance）指代一个关系的特定实例

### 2.1.2. 属性域（Domain of Attribute）

每个元素的允许取值的集合被称为该属性的属性域(Domain of Attribute)

关系中所有属性的属性域（通常）被视为原子的，即不可再分的

### 2.1.3. 空值null

特殊值null是每个属性域的成员。null意味着这个值是不存在的或者未知的

null会在许多操作的定义时导致一些复杂的问题，因此应该尽量避免空值

## 2.2. 数据库模式（database schema）

数据库模式（database schema）是数据库的逻辑结构

数据库实例（database instance）是给定时刻数据库中数据的一个快照

 

## 2.3. 键（keys）

键是用来区分一个给定关系中不同元组的一种方法。

超键（superkey）：超键是一个或多个元素的集合，这些属性可以使我们在一个关系中唯一地标识出一个元组

候选键（Candidate key）：超键中元素最少的称为候选键，即候选键的所有真子集均不是超键，所有超集全是超键，如ID就是候选键

主键（primary key）：一般在候选键中选出一个当作主键，主键不一定只有一个

外部键（foreign key）约束：一个关系中的值必须出现在另一个引用关系中，该值称为外部键

引用完整性约束：要求引用关系中的任意元组在指定属性上的取值也必然出现在被引用关系中至少一个元组的指定属性上

## 2.4. 模式图

一个带有主键和外部键约束的数据库模式可以用模式图（schema diagram）来表示。

在模式图中，

每个关系显示为一个框

关系名用灰色显示在顶部

主键用下划线标注

外部键约束用从引用关系的外部键属性指向被引用关系的主键属性的箭头表示

引用完整性约束用从引用关系的外部键属性指向被引用关系的属性的双箭头表示

## 2.5. 关系代数

^	and操作

v	or操作

¬	not操作

### 2.5.1. 基本操作

对一个关系的操作（一元运算，unary）：

选择运算（select：σ）

作用：从某张表中选出符合条件的行

语法：σ查询条件(表名)

投影运算（project：Π）

作用：将需要的列选出来合并成一张表并去重

语法：Π列名1,列名2,列名3...(表名)

更名运算（rename：ρ）

作用：将某个表重命名返回

语法：ρx(E)	返回以x命名的表达式E的结果

对两个关系的操作（二元运算，binary）

笛卡尔积运算（cartesian product：×）

作用：将两个表用笛卡尔积构造出一张新的表

语法：表1×表2

连接运算（join，⋈θ）

作用:将两个表根据等价条件用笛卡尔积进行构造

语法:r ⋈θs = σθ(r x s)，其中θ为两张表中的等价条件，如instructor.ID=teacher.ID

并集运算（union：∪）

作用：将两张表按照列合并起来

语法：表1∪表2

注意：并运算要求两张表具有相同的属性，因此一般需要先用投影运算处理

集差运算（set difference：﹣）

作用：使我们能够找到在一个关系中但不在另一个关系中的元组

语法：表1-表2

注意：注意点与并集运算一样

 

 

 

 

SQL利用:符号来区别其他语言的变量

 

 

 

 

# 3. 第5章 高级SQL

## 3.1. 使用程序设计语言访问SQL

### 3.1.1. 在程序设计语言中访问SQL的两种方式

1、动态SQL（dynamic SQL）

动态SQL指通用语言可以通过一组api来连接到数据库服务器并与之通讯

动态SQL允许程序在运行时以字符串形式来构建SQL查询，提交查询，然后把结果以元组的形式存入程序变量中，动态SQl组件允许程序在运行时构建和提交SQL查询

动态SQL的标准：JDBC（用于java语言）、ODBC（用于C语言）

2、嵌入式SQL（embedded SQL）

在嵌入式SQL中，SQL语句在编译时采用预处理器来进行识别，预处理器将嵌入式SQL表达的请求转化为函数调用，在运行时，这些函数调用使用提供动态SQL设置的API连接到数据库，但这些API可能只适用于正在使用的数据库

### 3.1.2. JDBC（待补充）

JDBC定义了用于将java程序连接到数据库服务器的应用程序接口

使用方式

 

 

### 3.1.3. ODBC

ODBC（Open DataBase Connectivity，开放数据库连接）标准定义了一个API，应用程序可以用它来打开一个数据库并操作数据库

每个支持ODBC的数据库系统都提供一个必须和客户端程序相连接的库。当客户端程序调用一个ODBC API时，库中的代码就和服务器进行通信以执行被请求的动作并获取结果

 

### 3.1.4. 嵌入式SQL

 

 

 

# ER模型

## 数据库设计方式

ER模型

Normalization Theory

## 模型组成

#### 五个基本组成

- 实例集
- 属性（每个实例与关联（relationship））
- 关联集
- 键（keys）
- mapping Cardinalities

#### Entity Set（实例集）

Model a database from design perspective, not programming perspective

从设计角度而非编程角度对数据库建模





















注意：即使遵守了BCNF规则，也不一定能严格规范化





# 第七章关系型数据库设计

## 好的关系设计的特点



## 符号惯例

希腊字母表示属性集

大写的罗马字母表示关系模式

r(R)表示具有模式R的关系r

K表示是一个超码的属性集

> 一个关系模式是一个属性集，但是并非所有的属性集都是模式
>
> 当使用小写的希腊字母时，我们只一个可能是模式也可能不是模式的属性集，但如果一个属性集肯定是一个模式时就用罗马字母

## 函数依赖

### 函数依赖概念

函数依赖指的是在合法的关系集合中的约束

- 要求一个确定属性集的值唯一地决定另一个属性集的值
- 函数依赖是key概念(notion)的一种泛化(generalization)
- 函数依赖关系允许我们查找/定义左侧不是超级键的依赖关系
- 函数依赖还可以帮助我们找到非法的依赖关系

### 函数依赖定义

![image-20220418165848135](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20220418165848135.png)

### 在函数依赖中key的定义

如果函数依赖K->R在r(R)上成立，则K是r(R)的一个超码

K->R的定义见上

### 平凡的(trivial)函数依赖

被所有关系满足的函数依赖称为平凡的(trivial)

- 一些常见的平凡的函数依赖
  - A->A
  - AB->A
  - 一般来说，如果b属于a，则形如a->b的函数依赖是平凡的

### 函数依赖集的闭包(Closure)

闭包指的是能够从给定的集合F中推导出的所有函数依赖的集合

我们用F^+^表示集合F的闭包

### 函数依赖的种类(Categories)

### 函数依赖的使用

### 无损分解(proper decomposition)

R~1~和R~2~构成R的一个无损分解的条件是以下函数依赖中至少有一个是在F^+^中

- R~1~交R~2~ -> R~1~
- R~1~交R~2~ -> R~2~

> 即当R1交R2构成R1或R2的超码时，R的该分解就是一个无损分解

如果我们采用此无损分解将一个关系模式r(R)分解为r1(R1)和r2(R2)，其中R1交R2 - >R1(推出R2也行)，则需要添加以下约束条件

- R1交R2是r1的主码
  - 此约束强制实施该函数依赖性
- R1交R2是从r2引用r1的外码
  - 这个约束确保r2中的每个元组在r1中都有一个匹配元组，如果没有这个匹配元组，他就不会出现在r1和r2的自然连接中

### 函数依赖的有损分解(improper(Lossy) decomposition)

### 判断是否保持函数依赖的算法



## 普通范式

### 原子域与第一范式(Atomic Domains and First Normal Form)

#### 第一范式

如果关于函数依赖集F的关系模式R属于BCNF，则需要满足以下条件

对于F^+^中所有形如a->b的函数依赖(其中a、b均属于R)，下面至少有一项成立

- a->b是平凡的函数依赖
- a是模式R的一个超码

### 第三范式

如果关于函数依赖集F的关系模式R属于第三范式，则需要满足以下条件

对于F^+^中所有形如a->b的函数依赖(其中a、b均属于R)，下面至少有一项成立

- a->b是平凡的函数依赖
- a是模式R的一个超码
- b-a中的每个属性A都被包含于R的一个候选码中

> 注意：第三个条件并不是说单个候选码必须包含b-a中的所有属性，而是指b-a中的每个属性A都可能被包含于不同的候选码中

### BCNF与第三范式的比较

- 第三范式的优点
  - 总可以在不牺牲无损性或依赖保持性的前提下得到第三范式的设计
- 第三范式的缺点
  - 可能不得不用控制来表示数据项之间的某些可能有意义的联系，并且存在信息重复的问题

我们以你该用函数依赖进行数据库设计的目标

- BCNF
- 无损性
- 依赖保持性

#### 无损连接分解(Lossless-join Decomposition)

#### BCNF与依赖性保护(Dependency Preservation)



#### 规范化目标

### 函数依赖理论与算法

#### 函数依赖理论

#### Armstrong’s Axioms(阿姆斯特朗公理)

- 自反律(reflexivity rule)
  - 若a为一个属性集且b属于a，则a->b成立
- 增补律(augmentation rule)
  - 若a->b成立且y为一个属性集，则ya->yb成立
- 传递律(transitivity rule)
  - 若a->b成立且b->y成立，则a->y成立

#### 阿姆斯特朗公理的附加规则(推论)

- 合并律(union rule)
  - 若a->b成立且a->y成立，则a->by成立
- 分解律(decomposition)
  - 若a->by成立，则a->b成立且a->y成立
- 伪传递律(pseudotransitivity rule)
  - 若a->b成立且yb->o成立，则ay->p成立

#### 计算F^+^的过程

F^+^ = F

应用自反律生成所有的平凡依赖

repeat

​	for each F^+^中的函数依赖f

​		在f上应用增补律

​		将函数依赖的结果加入F^+^中

​	for each F^+^中的一对函数依赖f~1~和f~2~

​		if f~1~和f~2~可以使用传递律进行结合

​			将函数依赖的结果加入F^+^中

until F^+^不再发生变化

#### 属性集的闭包

如果a->B，则称属性B被a函数决定(functionally determine)

计算F下a的闭包a^+^的算法

```
result:= a;
repeat
	for each 函数依赖 b->y in F do
		begin
			if b属于result then result:=result并y;
		end
until(result不发生改变)
```

#### 属性闭包的用途

- 为了检测a是否为超码，我们计算a^+^，并检查a^+^是否包含R中所有属性
- 通过检查是否b属于a^+^，我们可以检查一个函数依赖a->b是否成立(即是否属于F^+^)
- 该算法给了我们另一种计算F^+^的可替代方法
  - 对于任意的y属于R，我们找出闭包y^+^，并且对于任意的S属于y^+^，我们输出一个函数依赖y->S

#### Canonical Cover(正则覆盖)



#### Extraneous Attributes(无关属性)



### 使用函数依赖进行分解(Decomposition)和测试

BCNF分解

1. 检验R是否属于BCNF。如果是，不需要做任何事，返回{R}作为结果。
2. 如果存在BCNF违例，假设为X→Y。计算X+。选择R1=X+作为一个关系模式，并使另一个关系模式R2包含属性X以及那些不在X+中的属性。
3. 计算R1和R2的FD集，分别记为S1和S2。
4. 递归地分解R1和R2。返回这些分解得到的结果集合。

### 更多的范式

### 数据库设计过程

# 第十二章物理存储系统

## 物理存储介质概述

计算机系统中有代表性的可用介质包括一下几种

- 高速缓存(cache)
  - 高速缓存是**最快且最昂贵**的存储形式
  - 高速缓存相对较小，由计算机系统硬件来管理它的使用
- 主存(main memory)
  - 主存是用于存放可被操作的数据的存储介质
  - 通用机器指令在主存上执行
  - 主存能够存放几十上百个GB的数据
  - 主内中的内容是易失的(volatile)
- 闪存(flash memory)
  - 闪存是非易失的(non-volatile)
  - 闪存的每字节代价比主存低，比硬盘高
  - 闪存广泛应用于照相机、手机等设备的数据存储
  - 闪存也被用来在USB闪存驱动器(即闪盘)中存储数据
  - 固态硬盘(SSD)在内部使用闪存来存储数据，但提供与磁盘类似的接口，允许以块为单位来存储或检索数据，这种接口称为面向块的接口(block-oriented interface)
    - 块规模通常从512字节到8KB不等
  - 磁盘存储器(magnetic-disk storage)
    - 