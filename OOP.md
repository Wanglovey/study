Concatenation	串联

alter	改变

brackets	括号

ctors	扇区

inhibits	抑制、禁止

dynamically		动态地

succession		连续

reference		引用、参考

parameter		参数

bindings		绑定

alias			别名

constant		常数

scoping rules	作用域

defaults			默认值

modify			修饰词



# 1. 变量

## 1.1. 全局变量

全局变量被定义在任何函数之外，利用extern后能够在cpp文件之间共享

static全局变量是禁止被外部cpp文件访问的（只能在本文件中使用）

## 1.2. 局部变量

static局部变量当第一次使用的时候会被初始化，之后值会一直被保存

# 2. string

使用string前必须引入<string.h>

## 2.1. string与char[]的区别

如果将一个char数组赋值给另外一个char数组是非法的（需要用指针进行操作），但将一个string对象赋值给另一个string对象是合法的

## 2.2. string的+运算符

string类型可以用+进行拼接运算

## 2.3. string s和string *ps的区别

string s;该语句使对象s被创建并被初始化

string *ps;	ps指针对象指向一个未知数（即未初始化）

## 2.4. string的几种常用方法

截取字符串：

s.substr(int pos,int len);	表示在字符串s的第pos位开始截取长度为len的字串

改变字符串

 

# 3. 动态分配内存

## 3.1. new和delete

c++使用new操作符去创建一个新对象并自动分配内存（注意：如果是数组返回的是指针对象），而用delete或者delete[]删除对象

## 3.2. 注意事项

1、不要使用delete去释放没有用new分配的内存

2、不要使用delete连续两次释放同一块内存

3、如果你用过new[]分配过数组，则需要用delete[]进行分配

4、如果你曾使用new分配过一个单独的实例（entity），则需要使用delete（无括号的）

5、应用delete去删除空指针是安全合法的

# 4. 引用(reference）

## 4.1. 什么是引用

char c;

char& r = c;	

上方的行为称为引用，引用之后访问r相当于将c绑定到了r上，修改r后c也会被修改（重新赋值r，c中内容也会改变）

当定义一个reference变量的时候，变量必须初始化，但当做参数列表时可以不初始化

## 4.2. 指针和引用的区别

引用									指针

不能为空								可以被设为空

依赖于一个存在的变量，即该变量的别名		指针是独立存在的对象

绑定仅能进行一次，不可重新绑定

## 4.3. 注意点

1、reference变量如果作为参数时，传递的实参必须是变量形式，不能是例如3*i的类型

2、不能用一个reference变量指向reference变量

3、不要用指针指向reference变量，但可以用reference变量指向指针，例如

int *& p是合法的

4、没有reference变量的数组

# 5. const

1、const标识符用于声明一个有常量值的变量

2、const变量不允许再次赋值或者改变其中的值

3、const变量必须初始化，除非是extern（外部引用）时

4、编译器会尽量避免为const分配内存，extern强制为const变量分配内存

5、const可以作为数组大小，即const x=1; int a[x]; 是合法的，但是x的值必须定好，不能通过输入去定义

6、const数组在编译时，有些编译器选择不去知道const数组的内容，因此例如下方的例子不一定合法：

const int i[] = { 1, 2, 3, 4 }

float f[i[3]];

7、const和指针混合使用时，按照就近原则，例如：

char * const q = “abc”;

上方的q是一个常量，则对q的内容是不可更改的，即q++是不合法的

但*q是一个char变量，因而*q = ’c’是合法的

 

const char* p;和char const *p;均表示*q是常量，*q不允许被更改

注意：char*p默认为常量指针，不允许直接将字符串赋值给*p

但允许将字符串直接赋值给char p[]所定义的p

 

变量指针无法指向常量，但常量指针（const int *p和char const *p）可以

C++提供了const_cast操作符，能够将常量转为变量

C++允许将函数的常量返回值赋值给一个变量

 

# 6. C++类

## 6.1. 类的定义

### 1、语法

```C++
class className

{

	Access specifiers:			// 访问修饰符：private、public、protected

	Date members/variables;		// 类的变量

	Member function(){}		//类的方法

} 
```

### 2、成员函数的定义

成员函数的定义既可以在类内部，也可以在类外部，在类内部的定义方式如上，在类外部的定义方法见下

```
class className

{

	Access specifiers:			// 访问修饰符：private、public、protected

	Date members/variables;		// 类的变量

	function functionName;		// 声明类的方法

}
```

```
className::functionName(){

	// 在此定义函数内容
	// 注意，在此处如果需要访问类中的变量，需要用::variables的方式访问
}
```

### 3、this指针

在C++中提供了this指针指向对象实例（注意，实例只有在对象声明后才会出现，在类声明的时候并不是实例）

### 4、注意点

访问限定符的说明：
（1）public成员可以在类外直接访问。
（2）protected和private成员在类外（在此将这两种限定符都可以看成是私有的，在继承出区别）不能够访问。
（3）它们的作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止。
（4）class的默认访问权限是private，而struct为public型(因为struct要兼容C)。C++常用的是class
（5）类外：即脱离了类的作用域或者说访问时不在类的成员函数中。

## 6.2. 类成员的调用方法

### 访问public类型成员

public类型可以直接使用`.`运算符进行访问（包括变量和函数）

### 访问private类型成员

C++中private类型不允许被外部访问，只能被类内部和类成员函数访问，注意子类是无法直接访问父类的私有成员

（1）可以通过公共函数为私有成员进行赋值，即在函数定义的时候可以直接访问私有成员

（2）可以利用公共函数的指针参数提取私有成员的的值

（3）可以利用公共函数的引用参数提取私有成员的的值

### 访问protect类型成员

protect类型和private类似，唯一的区别是protect类型的类成员能够被子类访问



## 6.3. C++对象的三大特性

### 6.3.1. 封装性

封装即隐藏对象的属性和实现细节，仅对外公开接口和对象进行交互，将数据和操作数据的方法进行有机结合。

C++的封装性主要利用访问限定符实现

注意：访问限定符本质上是给编译器使用的，数据放在内存中是没有任何限制的

封装是逻辑上的概念，成员函数并不存在于内存中，但成员变量存在于内存中

### 6.3.2. 继承性

C++继承性表现为子类（派生类）可以在父类（基类）的基础上进行再次创建

### 6.2.3. 多态性







## 6.4. 重载运算符和重载函数

C++ 允许在同一作用域中为某个**函数**和**运算符**指定多个定义，分别称为**函数重载**和**运算符重载**。

重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。

当您调用一个**重载函数**或**重载运算符**时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为**重载决策**。

### 6.4.1. 函数重载

略

### 6.4.2. 运算符重载

重载的运算符是带有特殊名称的函数，函数名是由关键字operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。

```
// 声明重载 + 运算符
Box operator+(const Box&);
// 定义重载 + 运算符的作用
Box operator+(const Box& b)
{
    Box box;
    box.length = this->length + b.length;
    box.breadth = this->breadth + b.breadth;
    box.height = this->height + b.height;
    return box;
}
```

以上样例作用为声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。

如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，如下所示：

```
Box operator+(const Box&, const Box&);
```



## 可重载运算符/不可重载运算符

下面是可重载的运算符列表：

| 双目算术运算符 | + (加)，-(减)，*(乘)，/(除)，% (取模)                        |
| -------------- | ------------------------------------------------------------ |
| 关系运算符     | ==(等于)，!= (不等于)，< (小于)，> (大于)，<=(小于等于)，>=(大于等于) |
| 逻辑运算符     | \|\|(逻辑或)，&&(逻辑与)，!(逻辑非)                          |
| 单目运算符     | + (正)，-(负)，*(指针)，&(取地址)                            |
| 自增自减运算符 | ++(自增)，--(自减)                                           |
| 位运算符       | \| (按位或)，& (按位与)，~(按位取反)，^(按位异或),，<< (左移)，>>(右移) |
| 赋值运算符     | =, +=, -=, *=, /= , % = , &=, \|=, ^=, <<=, >>=              |
| 空间申请与释放 | new, delete, new[ ] , delete[]                               |
| 其他运算符     | **()**(函数调用)，**->**(成员访问)，**,**(逗号)，**[]**(下标) |

下面是不可重载的运算符列表：

- **.**：成员访问运算符
- **.\***, **->\***：成员指针访问运算符
- **::**：域运算符
- **sizeof**：长度运算符
- **?:**：条件运算符
- **#**： 预处理符号
