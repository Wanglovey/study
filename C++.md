# C++部分基础知识点

## 函数的分文件编写

- 作用

让代码结构更加清晰

- 步骤

1. 创建后缀名为.h的头文件
2. 创建后缀名为.cpp的源文件
3. 在头文件中写函数的声明
4. 在源文件中写函数的定义

## 指针

- 指针的作用

可以通过指针间接访问内存

> - 内存编号是从0开始记录的，一般用十六进制数字表示
> - 可以利用指针保存地址

- 指针所占内存空间

指针所占空间大小为4字节

- 空指针

空指针：指针变量指向内存中编号为0的空间（即NULL）

用途：初始化指针变量

注意：空指针指向的内存是不可以访问的

- 野指针

野指针：指向非法的内存空间的指针叫做野指针

- const修饰指针

const修饰指针有三种情况：

1. const修饰指针——常量指针
2. const修饰常量——指针常量    
3. const既修饰指针，又修饰常量

- 常量指针

```
const int *p = &a;
```

特点：指针的指向可以修改，指针的值不可以修改

- 指针常量

```
int * const p = &a;
```

特点：指针的指向不可以改，指针指向的值可以改

- const既修饰指针，又修饰常量

```
const int * const p = &a;
```

特点：既不能修改指针的指向，又不能修改指针指向的值

- 指针和数组

作用：利用指针访问数组中的元素

```
int arr[10] = {1,2,3,4,5,6,7,8,9,10}
int *p = arr;	// 数组名就是数组的首地址
cout << *(p+i) <<endl; // 输出第i个元素

```

- 指针和函数

函数的指针参数（例如`int *t`），如果修改`*t`的值，则实参的值也会被修改，但如果令t重新指向一个地址，则实参的值不会被修改（形参和实参并不在同一个地址，仅仅只是指向的地址相同，形参是临时变量）

## 引用

- 引用的作用

给变量起别名

- 语法

```c++
数据类型 &别名 = 原名;
```

- 注意事项

1. 引用必须初始化
2. 引用在初始化后就不能改变了

- 引用做函数参数

作用：函数在传参时，可以利用引用的技术让形参修饰实参

优点：可以简化指针修改实参

即可以利用引用，直接将形参作为函数实参的别名，从而直接修改实参

- 引用做函数返回值

作用：引用是可以作为函数的返回值存在的

注意：

1. 不要返回局部变量的引用（不包括局部静态变量）
2. 引用作为函数返回值时，函数调用可以作为左值存在的

样例：

```C++
int &test(){
	static int a = 20;
	return a;
}

int main(){
    int &ref = test()	// ref作为了a的引用
    test() = 1000;		// 函数调用作为左值，此处操作即a = 1000
}
```

- 引用的本质

引用的本质是在C++内部实现一个指针常量（数据类型 * const 指针名）

可以理解为 `int& ref = a; 即 int * const ref = &a;`

- 常量引用

在函数形参列表中，可以添加const修饰形参，防止形参改变实参

作用：常量引用主要用来修饰形参，防止误操作

语法：

```
void f(const int& v){
	......
}
```



# C++核心编程

## 内存分区模型

### 内存四区

C++程序在执行时，将内存大方向划分为4个区域

- 代码区：存放函数体的二进制代码，由操作系统进行管理
- 全局区：存放全局变量、静态变量、全局常量、字符串常量
- 栈区：由编译器自动分配释放，存放函数的参数值，局部变量、局部常量等
- 堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收（主要由new和delete操作符进行操作）

内存四区的意义：

不同区域存放的数据赋予不同的生命周期，给我们更大的灵活编程

### 程序运行前

在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域

代码区：

​	存放CPU执行的机器指令

​	代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可

​	代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令

全局区：

​	全局变量和静态变量存放在此

​	全局区还包含了常量区，字符串常量和其他常量也存放在此

​	该区域的数据在程序结束后由操作系统释放

## 函数提高

### 函数默认参数

在C++中，函数的形参列表中的形参是可以有默认值的

注意事项：

1. 如果某个位置参数有默认值，那么从这个位置往后的参数都必须要有默认值（即默认参数一定要在位置参数后面）
2. 为避免二义性，函数声明和定义时只能在选择其中一个设置默认值

样例：

```
// 函数声明
返回值类型 函数名 (参数1 = 默认值2 [,...]);
// 函数定义
返回值类型 函数名 (参数1 [,...]) {}
```

### 函数占位参数

C++中的函数的形参列表里可以有占位参数，用来做占位

占位参数可以有默认值，有默认值时在调用函数时占位参数可以不填补，但如果占位参数没有默认值，则调用函数时必须填补该位置

> 占位参数即只声明变量类型但不赋予参数变量名的参数
>
> 占位参数还可以有默认参数

实例：

```
void func1(int a, int = 10) {
	cout<< "this is func" << endl;
}
void func2(int a, int) {
	cout<< "this is func" << endl;
}

int main(){
	func1(10);	// 有默认值的占位参数可以不填补
	func2(10,10);	// 无默认值的占位参数必须填补
	system("pause");
}
```

### 函数重载

- 函数重载作用

函数名可以相同，提高复用性

- 函数重载需满足的条件

1. 重载的函数在同一个作用域下
2. 函数名称相同
3. 函数参数 类型不同 或者 个数不同 或者顺序不同

> 注意：函数的返回值不可以作为函数重载的条件

- 函数重载的注意事项

1. 引用作为重载条件

   1. 引用可以利用有无const重载函数，当两种重载函数都存在的时候，如果传入的是实参是变量，调用的是无const的函数，如果传入的实参是常量，如数值，则会调用有const的函数

   2. > 原因：int &a = 常量;不合法，但是const int &a = 10;合法

2. 函数重载碰到函数默认参数

如果存在以下写法，会出现二义性，编译器会报错：

```
void func(int a, int b = 10){}
void func(int a){}
```

## 类和对象

C++面向对象的三大特性：封装，继承，多态

### 构造函数和析构函数

- 构造函数
  - 用于在创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用
- 析构函数
  - 用于在对象销毁前系统自动调用，执行一些清理工作

> 构造函数和析构函数都是由编译器自动强制调用，如果我们没有提供这两个函数，编译器也会提供，但是编译器提供的构造函数和析构函数是空实现

- 构造函数语法

1. 构造函数没有返回值也没有函数类型（也没有void类型）
2. 构造函数名称和类型相同
3. 构造函数可以有参数，因此可以发生重载
4. 程序在调用对象时候会自动调用构造函数，无需程序员手动调用，而且构造函数只会被调用一次

- 析构函数语法

1. 析构函数没有返回值也没有函数类型（也没有void类型）
2. 析构函数名称为类名前面加上符号~
3. 析构函数不可以有参数，因此不能够发生重载
4. 程序在对象销毁前会自动调用析构函数，无需程序员手动调用，而且析构函数只会被调用一次

- 构造函数和析构函数实例

```C++
class Person{
    Person(){
        cout<< "这是一个构造函数" <<endl;
    }
    ~Person(){
		cout<< "这是一个析构函数" <<endl;
    }
}
```

- 构造函数的分类和调用

两种分类方式

1. 按参数分为：有参构造和无参构造
2. 按类型分为：普通构造和拷贝构造

三种调用方式

1. 括号法
2. 显示法
3. 隐式转换法

拷贝构造实例

```
class Person(){
	Person(const Person &p){	// 拷贝构造函数的固定写法
		// 将传入对象的所有属性拷贝至新对象身上
		...
	}
}
```

括号法调用实例

```C++
Person p1;	// 默认构造函数调用
Person p2(10);	// 有参构造函数
Person p3(p2);	// 拷贝构造函数
// 上方两种例子都是括号法调用构造函数
```

> 注意：调用默认构造函数的时候不要加()，否则编译器会认为是函数声明而不是在创建对象

显示法调用实例

```C++
Person p1;
Person p2 = Person(10);	// 有参构造
Person p3 = Person(p2);	// 拷贝构造
```

> Person(10)称为匿名对象（即没有被赋予标识符的对象）
>
> 匿名对象特点：
>
> 当匿名对象所在行执行结束后，系统会立即自动释放匿名对象
>
> 不要利用拷贝构造函数初始化匿名对象，否则编译器认为Person(p3)等价于Person p3（即括号法调用构造函数），从而触发重定义，进而报错

隐式转换法调用实例

```C++
Person p4 = 10;	// 相当于写了 Person p4 = Person(10)
Person p5 = p4;	// 相当于写了 Person p5 = Person(p4)
```

- 拷贝构造函数的调用时机

1. 使用一个已经创建完毕的对象来初始化一个新对象
2. 值传递的方式给函数参数传值
3. 以值方式返回局部对象

- 构造函数的调用规则

默认情况下C++编译器至少给一个类添加3个函数

1. 默认构造函数（无参，函数体为空）
2. 默认析构函数（无参，函数体为空）
3. 默认拷贝构造函数，对属性进行值拷贝

构造函数调用规则如下：

1. 如果用户定义有参构造函数，C++不再提供默认无参构造，但是会提供默认拷贝构造
2. 如果用户定义拷贝构造函数，C++不会再提供其他构造函数

### 封装

- 封装的意义

1. 将属性和行为作为一个整体，表现生活中的事物
2. 将属性和行为加以权限控制

- 封装的语法

```
class 类名 {
访问权限：
	属性/行为
	...
}
```

- 访问权限

访问权限有三种：

1. public	     公共权限	类内可以访问，类外可以访问
2. protected  保护权限	类内可以访问，类外不可以访问，但子类可以访问
3. private       私有权限	类内可以访问，类外不可以访问

> 在C++中struct和classs唯一的区别就在于默认的访问权限不同
>
> struct默认权限为公共（public）
>
> class默认权限为私有（private）

- 成员属性为私有的好处

1. 将所有成员属性设置为私有，可以自己控制读写权限
2. 对于写权限，我们可以检测数据的有效性

### 继承

> 可以利用VS开发人员命令提示工具查看对象模型
>
> 1. 跳转盘符
> 2. 跳转到文件的具体路径
> 3. 查看命名
> 4. 在命令行中输入命令 cl / dl reportSingleClassLayout类名 文件名

- 语法

```C++
class 子类:继承方式 父类1 , 继承方式 父类2...
```

> 由于多继承可能会导致父类中有同名成员出现，因此需要加作用域区分
>
> 实际开发中不建议使用多继承

- 继承方式

1. 公共继承（父类中的成员权限不变）
2. 保护继承（父类中的公有成员变为子类的保护成员）
3. 私有继承（父类中的公有成员和保护成员变为子类的私有成员）

> 注意：
>
> 1. 无论是哪种继承方式，都无法访问父类中的私有成员（会被子类继承，只是被隐藏了，无法访问）
> 2. 父类中的所有非静态成员都会被子类继承，包括私有成员（可以通过sizeof(子类)验证）

- 继承中构造和析构的顺序

构造顺序：先构造父类再构造子类

析构顺序：与构造相反

- 继承中的同名成员

子类中如果有和父类同名的成员时，父类的同名成员会被隐藏

子类对象如果要调用父类的同名成员，需要加上作用域

> 同名静态成员和同名非静态成员的处理方法一致

语法：

```
子类.父类::同名属性
```

- 菱形继承的解决方案

菱形继承指子类的两个父类都来自一个共同的爷爷类，因此在初始化的时候需要利用作用域区分同名变量，同时需要利用虚继承解决重复的爷爷造成的空间浪费的问题

虚继承：

子类继承之前在父类加上关键字virtual后就会变为虚继承

```
class grandfa
{
	// 成员
}
class father1:virtual public grandfa
{
	// 成员
}
class father2:virtual public grandfa
{
	// 成员
}
class child:public father1, public father2
{
	// 成员
}
```

虚继承原理：

```
被虚继承的类称为虚基类，这种继承方式不是简单的值继承，而是利用指针进行继承，因此上面的child类中被继承的grandfa类由于被继承的指针所指向的位置相同，因此不会多占用额外重复的空间，只会占用一个空间
```

### 多态

- 多态分为两类

1. 静态多态：函数重载和运算符重载都属于静态多态
2. 动态多态：派生类和虚函数实现运行时多态

- 静态多态和动态多态的区别

1. 静态多态的函数地址早绑定（编译阶段确定函数地址）（即函数参数的类型是确定的，不能随着传入的对象不同而产生不同的效果）
2. 动态多态的函数地址晚绑定（运行阶段确定函数地址）

- 动态多态满足的条件

1. 有继承关系
2. 子类重写父类中的虚函数

- 动态多态的使用

1. 父类的指针或引用执行子类的对象（因为C++允许当父类作为形参时，传入子类实参）

> 注意：C++允许子类转化成父类

> 可以利用虚函数（即在函数名面前添加virtual），将子类中的同名函数转化成虚函数进行重写（重写指函数的返回值类型、函数名、参数列表完全相同），将早绑定的地址转化成晚绑定的地址

- 多态的原理

多态中虚函数的原理：

C++编译器在存储虚函数的过程中存储的是虚指针，该指针指向的是虚函数的地址

- 多态的意义

1. 可以实现即用即毁
2. 组织结构清晰
3. 可读性强
4. 对于前期和后期扩展以及维护性高

### 深拷贝和浅拷贝

浅拷贝：简单的赋值操作，可以理解为仅仅只是将地址赋值过去

深拷贝：在堆区重新申请空间，进行拷贝操作

> 注意：如果程序员没有自定义拷贝构造函数，编译器自动提供的拷贝构造函数是浅拷贝

浅拷贝带来的问题：堆区的内存会被析构函数重复释放

> 实际使用中除了引用外，一定要避免浅拷贝

### 初始化列表

C++提供了初始化列表语法用来初始化属性

语法：

```
class Person{
public:
	Person(int a,int b, int c):m_A(a), m_B(b), m_C(c)	# 初始化列表
	{
	
	}
	int m_A;
	int m_B;
	int m_C;
}
```

- 类对象作为类成员时的构造和析构顺序

构造顺序：当其他类对象作为本类成员，构造的时候先构造其他类对象（即类成员），再构造自身

析构顺序：与构造相反

### 静态成员

静态成员就是在成员变量和成员函数前加上关键字static

静态成员分为静态成员变量和静态成员函数

- 静态成员变量
  - 所有对象共享同一份数据
  - 在编译阶段分配内存
  - 类内声明，类外初始化

> 静态成员变量可以通过类名::变量名的方式访问

- 静态成员函数

  - 所有对象共享同一个函数

  - 静态成员函数只能访问静态成员变量，无法访问非静态成员变量，会报错

  - > 静态成员函数在对象实例创建前就已经存在了，此时非静态成员变量还未定义

```
class Person{
	static int A;	// 静态成员类内声明
}

int Person::A = 100;	// 静态成员类外初始化
```

### C++对象模型

在C++中空对象（没有任何属性和方法的对象）占用的内存为1字节

> C++编译器会给每个空对象也分配一个字节的空间，用于区分空对象占内存的位置

但如果对象中有成员，则按照成员的大小来分配内存，不再分配给空对象1个字节

- 成员变量和成员函数的存储位置

在C++中，类内的成员变量和成员函数分开存储

只有非静态的成员变量才属于类的对象

- this指针

C++提供this指针指向被调用的成员函数所属的对象

this指针是隐含在每一个非静态成员函数内的一种指针，this指针不需要定义，直接使用即可

> this指针的本质是指针常量，this指针的指向是不可以被修改的

this指针的用途：

1. 当形参和成员变量同名时，可用this指针来区分
2. 在类的非静态成员函数中返回对象本身，可使用`return *this`

- 空指针访问成员函数

C++中空指针也可以调用成员函数，但是要注意成员函数中是否使用了this指针，如果使用了this指针，则需要加以判断来确保代码的健壮性

判断条件为：

```
在使用了this的成员函数内部最前方写入如下代码：
if(this == NULL){
	return ;
}
```

- `const` 修饰成员函数

常函数

1. 在成员函数的函数名() 后加 `const`
2. 常函数内不可以修改成员属性（重点）
3. 成员属性声明时如果加了关键字 `mutable` ，则在常函数中依然可以修改

> 常函数本质上是修饰this指针，让this指针指向的值也不可以被修改

常对象

1. 声明对象前加 `const` 则称该对象为常对象
2. 常对象只能调用常函数（但常函数可以被所有对象调用）
3. 常对象只能修改带有关键字mutable的属性

```C++
// 常函数和常对象写法实例
class Person
{
public:
	void showPerson() const		// 常函数
	{
		this->m_B = 100;	// 常函数中只能修改带有mutable的特殊变量 
	}
	mutable int m_B;	// 特殊变量，即使在常函数中也可以修改
}

int main(){
	const Person p;	// 常对象
}
```

### 友元

- 友元的目的

让一个函数或者类访问里另一个类中的私有成员

友元的关键字是 `friend` 

- 友元的三种实现方式

1. 全局函数做友元
2. 类做友元
3. 成员函数做友元

- 友元实例

```C++
class GoodGay;	// 这样写目的是告诉编译器GoodGay类已经声明，避免下方写友元的时候报错
class Building
{
    // 注意：友元的声明位置无所谓，只要在类中就行
    friend void goodGay(Building *building); // 友元全局函数
    friend class GoodGay;	// 友元类
    friend void GoodGay::visit2();	// 设置友元成员函数
public:
    int a;
private:
    int b;
};

class GoodGay
{
    Building building;
    GoodGay()
    {
        building = new Building;
    }
    void visit1()
    {
        cout<< building->b <<endl;	// 报错，无法成功访问
    }
    void visit2()
    {
        cout<< building->b <<endl;	// 可以成功访问
    }
}


// 全局函数
void goodGay(Building *building)	// 指针或者引用均可
{
    cout<< building->b <<endl;
}

int main()
{
	Building b;
    b->b = 10;
    goodGay(b);
}
```

### 运算符重载

> 运算符重载也可以发生函数重载

> 下方实例为重载 + 号运算符，还可以利用左移运算符（<<）重载自定义输出类型，左移运算符重载只能用全局函数进行重载，否则无法实现cout在左侧

> C++编译器会至少给一个类添加4个函数，构造、析构、拷贝构造和赋值运算符 = 重载，其中，编译器提供的赋值运算符 = 作用也是对对象进行浅拷贝，如果需要深拷贝则需要程序员重载=号运算符

> 函数调用运算符，即 `()` 运算符
>
> 由于重载后的使用方式非常像函数的调用，因此称为仿函数
>
> 仿函数没有固定写法，非常灵活
>
> 重载后的调用实例如下：
>
> ```C++
> Person p;
> p("你好");	// 其中"你好"为参数
> ```
>
> 

- 运算符重载语法

```C++
返回值类型 operator运算符(参数)	// 参数只有一个
{
	// 重载的内容
	return 返回值;
}
```



- 成员函数重载运算符

```C++
class Person
{
public:
	int m_A;
	int m_B;
    Person operator+(Person &p)
    {
        Person temp;
        temp.m_A = this.m_A + p.m_A;
        temp.m_B = this.m_B + p.m_B;
        return temp;
    }
}

int main()
{
    Person a,b;
    a = a + b;	// 本质是a.operator+(b)
}
```

- 全局函数重载运算符

```C++
class Person
{
public:
	int m_A;
	int m_B;
}
Person operator+(Person &p1,Person &p2)	// Person为函数返回值类型
{
    Person temp;
    temp.m_A = p1.m_A + p2.m_A;
    temp.m_B = p1.m_B + p2.m_B;
    return temp;
}
int main()
{
    Person a,b;
    a = a + b;	// 本质是operator+(a,b)
}
```

- 左移运算符重载实例

```C++
ostream operator<<(ostream &cout ,Person &p)	//本质是operator<<(cout,p)，简化为cout<<p
{
	cout<<"m_A = "<<p.m_A << " m_b = "<<p.m_B;
    return cout;	// 因为cout采用了链式编程的思想，为了让cout后续的式子可以正常运行，因此需要返回cout
}
int main()
{
    Person p;
    cout<<p;
}
```

# 文件操作

## 基础知识

- 文件类型

1. 文本文件：文件以文本的ASCII码形式存储在计算机中
2. 二进制文件：文本以文本的二进制形式存储在计算机中

- 操作文件的三大类

1. ofstream：写操作
2. ifstream：读操作
3. fstream：读写操作

## 文本文件

### 写文件

- 步骤

1. 包含头文件`#include <fstream>`
2. 创建流对象 `ofstream ofs;` 或者 `fstream ofs;`
3. 打开文件 `ofs.open("文件路径", 打开方式)`
4. 写数据 `ofs << "写入的数据";`
5. 关闭文件 `ofs.close()`

- 文件打开方式

| 打开方式    | 解释                       |
| ----------- | -------------------------- |
| ios::in     | 为读文件而打开文件         |
| ios::out    | 为写文件而打开文件         |
| ios::ate    | 初始位置：文件末尾         |
| ios::app    | 追加方式写文件             |
| ios::trunc  | 如果文件存在则先删除再创建 |
| ios::binary | 二进制方式                 |

> 打开凡是可以配合使用，利用 | 操作符
>
> 例如用二进制方式写文件：`ios::binary | ios::out`
